{"ast":null,"code":"import { pathToRegexp, match } from \"path-to-regexp\";\nimport { render, html, hydro, $, $$, setReuseElements } from \"hydro-js\";\nlet router;\nconst storageKey = \"router-scroll\";\nconst outletSelector = \"[data-outlet]\";\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst fetchCache = new WeakMap();\nlet base = $(\"base\")?.getAttribute(\"href\") || \"\";\nif (base.endsWith(\"/\")) {\n  base = [...base].slice(0, -1).join(\"\");\n}\naddEventListener(\"popstate\", async e => {\n  router?.doRouting(location.pathname + location.search, e);\n});\n// Reload -> store scrollPosition\naddEventListener(\"beforeunload\", () => sessionStorage.setItem(`${storageKey}-${location.pathname + location.search}`, `${scrollX} ${scrollY}`));\nexport default class Router {\n  options;\n  routes;\n  oldRoute;\n  constructor(routes, options = {}) {\n    // Handle nested routes\n    const length = routes.length - 1;\n    for (let i = length; i >= 0; i--) {\n      const route = routes[i];\n      if (route.children) {\n        route.children.forEach((child, idx) => {\n          routes.splice(i + idx, 0, {\n            ...child,\n            path: `${route.path}/${child.path}`,\n            isChildOf: route\n          });\n        });\n        Reflect.deleteProperty(route, \"children\");\n      }\n    }\n    const newRoutes = routes.map(route => {\n      return {\n        restoreScroll: true,\n        ...route,\n        path: pathToRegexp(base + route.path),\n        originalPath: base + route.path\n      };\n    });\n    this.routes = newRoutes;\n    this.options = options;\n    router = this;\n    // Prefetch resources\n    this.routes.forEach(route => {\n      // @ts-expect-error\n      if (route.templateUrl && !navigator.connection?.saveData) {\n        const controller = new AbortController();\n        const cache = {\n          promise: null,\n          controller\n        };\n        fetchCache.set(route, cache);\n        setTimeout(() => {\n          requestIdleCallback(() => {\n            cache.promise = fetch(route.templateUrl, {\n              signal: controller.signal\n            });\n            cache.promise.then(res => res.text()).then(_html => {\n              cache.html = _html;\n            }).catch(async err => {\n              await this.options.errorHandler?.(err);\n            });\n          });\n        });\n      }\n    });\n    this.doRouting();\n  }\n  getMatchingRoute(path) {\n    if (path.startsWith(\".\")) {\n      path = path.replace(\".\", \"\");\n    }\n    return this.routes.find(route => route.path.exec(path));\n  }\n  async doRouting(to = location.pathname + location.search, e) {\n    dispatchEvent(new Event(\"beforeRouting\"));\n    const from = this.oldRoute ?? to;\n    const route = this.getMatchingRoute(to);\n    if (route) {\n      // Store position\n      let currStorageKey;\n      if (this.oldRoute) {\n        currStorageKey = `${storageKey}-${from}`;\n        sessionStorage.setItem(currStorageKey, `${scrollX} ${scrollY}`);\n      }\n      try {\n        const {\n          params\n        } = match(route.originalPath, {\n          decode: decodeURIComponent\n        })(to);\n        const allParams = {\n          ...Router.getParams(),\n          ...Object.fromEntries(Object.entries(params).map(pair => Number.isNaN(Number(pair[0])) && pair).filter(Boolean))\n        };\n        const props = {\n          from: from.replace(base, \"\"),\n          to: to.replace(base, \"\"),\n          ...(Object.keys(allParams).length ? {\n            params: allParams\n          } : {}),\n          ...(history.state && Object.keys(history.state).length ? {\n            state: history.state\n          } : {})\n        };\n        // Trigger leave\n        if (this.oldRoute) {\n          const oldRoute = this.routes.find(route => route.path.exec(this.oldRoute));\n          if (oldRoute) {\n            await oldRoute[\"leave\" /* cycles.leave */]?.(props);\n            this.oldRoute = route.originalPath;\n          }\n        }\n        // Trigger beforeEnter\n        await route[\"beforeEnter\" /* cycles.beforeEnter */]?.(props);\n        // Handle template / element\n        if (!!route.isChildOf) {\n          setReuseElements(false);\n          const parent = route.isChildOf;\n          if (parent.templateUrl) {\n            await handleTemplate(parent, $(outletSelector));\n          } else if (parent.element) {\n            const copy = $(outletSelector).cloneNode();\n            copy.append(html`${parent.element}`);\n            render(copy, outletSelector, false);\n          }\n          setReuseElements(true);\n        }\n        const where = route.isChildOf ? $(outletSelector).querySelector(outletSelector) : $(outletSelector);\n        if (route?.templateUrl) {\n          await handleTemplate(route, where);\n        } else if (route?.element) {\n          const copy = where.cloneNode();\n          copy.append(html`${route.element}`);\n          render(copy, where, false);\n        } else {\n          // Clear outlet\n          $(outletSelector).textContent = null;\n        }\n        currStorageKey = `${storageKey}-${to}`;\n        // Trigger afterEnter\n        await route[\"afterEnter\" /* cycles.afterEnter */]?.(props);\n      } catch (err) {\n        if (this.options.errorHandler) {\n          await this.options.errorHandler(err, e);\n        } else {\n          console.error(err, e);\n        }\n      } finally {\n        // Reload -> restore scroll position\n        if (route.restoreScroll && sessionStorage.getItem(currStorageKey)) {\n          const [left, top] = sessionStorage.getItem(currStorageKey).split(\" \").map(Number);\n          sessionStorage.removeItem(currStorageKey);\n          scrollTo({\n            top,\n            left,\n            behavior: this.options.scrollBehavior || \"auto\"\n          });\n        } else {\n          // Reset Scroll, just like Browser\n          if (!window.isHMR) {\n            scrollTo({\n              top: 0,\n              left: 0,\n              behavior: this.options.scrollBehavior || \"auto\"\n            });\n          }\n        }\n        dispatchEvent(new Event(\"afterRouting\"));\n      }\n    }\n  }\n  go(path, state, params = \"\") {\n    this.oldRoute = location.pathname + location.search;\n    const newPath = base + path + params;\n    // Only navigate when the path differs\n    if (newPath !== this.oldRoute) {\n      history.pushState({\n        ...state\n      }, \"\", newPath);\n      this.doRouting(newPath);\n    }\n  }\n  removeRoute(path) {\n    const idx = this.routes.findIndex(route => String(route.path) === String(pathToRegexp(path)));\n    if (idx > -1) {\n      this.routes.splice(idx, 1);\n    }\n  }\n  addRoute(route) {\n    this.routes.push({\n      ...route,\n      path: pathToRegexp(base + route.path),\n      originalPath: base + route.path\n    });\n  }\n  modifyRoute(path, newRoute) {\n    const idx = this.routes.findIndex(route => String(route.path) === String(pathToRegexp(path)));\n    if (idx > -1) {\n      this.routes[idx] = {\n        ...newRoute,\n        path: pathToRegexp(base + newRoute.path),\n        originalPath: base + path\n      };\n    }\n  }\n  changeOptions(options) {\n    this.options = options;\n  }\n  static getParams(search = location.search) {\n    return Object.fromEntries(new URLSearchParams(search));\n  }\n}\nfunction registerAnchorEvent(anchor) {\n  if (anchor.getAttribute(\"href\")?.startsWith(\"http\")) return;\n  anchor.addEventListener(\"click\", e => {\n    e.preventDefault();\n    const hasData = anchor.getAttribute(\"data\");\n    const hydroProp = replaceBars(hasData);\n    const href = anchor.getAttribute(\"href\") || \"\";\n    router.go(href, hasData ? hydro[hydroProp] : void 0);\n  });\n}\nfunction registerFormEvent(form) {\n  form.addEventListener(\"submit\", e => {\n    if (!router.options.formHandler) return;\n    e.preventDefault();\n    const action = form.getAttribute(\"action\");\n    const method = form.getAttribute(\"method\");\n    fetch(action, {\n      method,\n      ...(![\"HEAD\", \"GET\"].includes(method.toUpperCase()) ? {\n        body: new FormData(form)\n      } : {}),\n      ...router.options.fetchOptions\n    }).then(res => router.options.formHandler(res, e)).catch(async err => {\n      if (router.options.errorHandler) {\n        await router.options.errorHandler(err, e);\n      } else {\n        console.error(err, e);\n      }\n    });\n  });\n}\nfunction replaceBars(hydroTerm) {\n  if (hydroTerm === null || !hydroTerm.includes(\"{{\")) return hydroTerm;\n  const [_, hydroPath] = hydroTerm.match(reactivityRegex) || [];\n  return hydroPath;\n}\n// Add EventListener for every added anchor and form Element\n$$(\"a\").forEach(registerAnchorEvent);\n$$(\"form\").forEach(registerFormEvent);\nnew MutationObserver(entries => {\n  for (const entry of entries) {\n    for (const node of entry.addedNodes) {\n      const nodes = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, {\n        acceptNode(elem) {\n          return [\"form\", \"a\"].includes(elem.localName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n        }\n      });\n      let formOrA;\n      while (formOrA = nodes.nextNode()) {\n        if (formOrA.localName === \"a\") {\n          registerAnchorEvent(formOrA);\n        } else {\n          registerFormEvent(formOrA);\n        }\n      }\n    }\n  }\n}).observe(document.body, {\n  childList: true,\n  subtree: true\n});\nasync function handleTemplate(route, where) {\n  let cacheObj = fetchCache.get(route);\n  if (!fetchCache.has(route) || cacheObj?.promise === null) {\n    cacheObj?.controller?.abort();\n    const data = await fetch(route.templateUrl);\n    if (!cacheObj) {\n      cacheObj = {\n        html: await data.text()\n      };\n      fetchCache.set(route, cacheObj);\n    } else {\n      cacheObj.html = await data.text();\n    }\n  }\n  Reflect.deleteProperty(cacheObj, \"controller\");\n  const copy = where.cloneNode();\n  copy.append(window.isHMR || !cacheObj?.hasOwnProperty(\"html\") ? html`${await (await fetch(route.templateUrl)).text()}` : html`${(await cacheObj.html) || \"\"}`);\n  render(copy, where, false);\n}","map":{"version":3,"names":["pathToRegexp","match","render","html","hydro","$","$$","setReuseElements","router","storageKey","outletSelector","reactivityRegex","fetchCache","WeakMap","base","getAttribute","endsWith","slice","join","addEventListener","e","doRouting","location","pathname","search","sessionStorage","setItem","scrollX","scrollY","Router","options","routes","oldRoute","constructor","length","i","route","children","forEach","child","idx","splice","path","isChildOf","Reflect","deleteProperty","newRoutes","map","restoreScroll","originalPath","templateUrl","navigator","connection","saveData","controller","AbortController","cache","promise","set","setTimeout","requestIdleCallback","fetch","signal","then","res","text","_html","catch","err","errorHandler","getMatchingRoute","startsWith","replace","find","exec","to","dispatchEvent","Event","from","currStorageKey","params","decode","decodeURIComponent","allParams","getParams","Object","fromEntries","entries","pair","Number","isNaN","filter","Boolean","props","keys","history","state","parent","handleTemplate","element","copy","cloneNode","append","where","querySelector","textContent","console","error","getItem","left","top","split","removeItem","scrollTo","behavior","scrollBehavior","window","isHMR","go","newPath","pushState","removeRoute","findIndex","String","addRoute","push","modifyRoute","newRoute","changeOptions","URLSearchParams","registerAnchorEvent","anchor","preventDefault","hasData","hydroProp","replaceBars","href","registerFormEvent","form","formHandler","action","method","includes","toUpperCase","body","FormData","fetchOptions","hydroTerm","_","hydroPath","MutationObserver","entry","node","addedNodes","nodes","document","createNodeIterator","NodeFilter","SHOW_ELEMENT","acceptNode","elem","localName","FILTER_ACCEPT","FILTER_REJECT","formOrA","nextNode","observe","childList","subtree","cacheObj","get","has","abort","data","hasOwnProperty"],"sources":["C:/Users/DELL/OneDrive/Desktop/REACTJS/myshop/node_modules/router-dom/dist/router.js"],"sourcesContent":["import { pathToRegexp, match } from \"path-to-regexp\";\nimport { render, html, hydro, $, $$, setReuseElements } from \"hydro-js\";\nlet router;\nconst storageKey = \"router-scroll\";\nconst outletSelector = \"[data-outlet]\";\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst fetchCache = new WeakMap();\nlet base = $(\"base\")?.getAttribute(\"href\") || \"\";\nif (base.endsWith(\"/\")) {\n    base = [...base].slice(0, -1).join(\"\");\n}\naddEventListener(\"popstate\", async (e) => {\n    router?.doRouting(location.pathname + location.search, e);\n});\n// Reload -> store scrollPosition\naddEventListener(\"beforeunload\", () => sessionStorage.setItem(`${storageKey}-${location.pathname + location.search}`, `${scrollX} ${scrollY}`));\nexport default class Router {\n    options;\n    routes;\n    oldRoute;\n    constructor(routes, options = {}) {\n        // Handle nested routes\n        const length = routes.length - 1;\n        for (let i = length; i >= 0; i--) {\n            const route = routes[i];\n            if (route.children) {\n                route.children.forEach((child, idx) => {\n                    routes.splice(i + idx, 0, {\n                        ...child,\n                        path: `${route.path}/${child.path}`,\n                        isChildOf: route,\n                    });\n                });\n                Reflect.deleteProperty(route, \"children\");\n            }\n        }\n        const newRoutes = routes.map((route) => {\n            return {\n                restoreScroll: true,\n                ...route,\n                path: pathToRegexp(base + route.path),\n                originalPath: base + route.path,\n            };\n        });\n        this.routes = newRoutes;\n        this.options = options;\n        router = this;\n        // Prefetch resources\n        this.routes.forEach((route) => {\n            // @ts-expect-error\n            if (route.templateUrl && !navigator.connection?.saveData) {\n                const controller = new AbortController();\n                const cache = { promise: null, controller };\n                fetchCache.set(route, cache);\n                setTimeout(() => {\n                    requestIdleCallback(() => {\n                        cache.promise = fetch(route.templateUrl, {\n                            signal: controller.signal,\n                        });\n                        cache.promise\n                            .then((res) => res.text())\n                            .then((_html) => {\n                            cache.html = _html;\n                        })\n                            .catch(async (err) => {\n                            await this.options.errorHandler?.(err);\n                        });\n                    });\n                });\n            }\n        });\n        this.doRouting();\n    }\n    getMatchingRoute(path) {\n        if (path.startsWith(\".\")) {\n            path = path.replace(\".\", \"\");\n        }\n        return this.routes.find((route) => route.path.exec(path));\n    }\n    async doRouting(to = location.pathname + location.search, e) {\n        dispatchEvent(new Event(\"beforeRouting\"));\n        const from = this.oldRoute ?? to;\n        const route = this.getMatchingRoute(to);\n        if (route) {\n            // Store position\n            let currStorageKey;\n            if (this.oldRoute) {\n                currStorageKey = `${storageKey}-${from}`;\n                sessionStorage.setItem(currStorageKey, `${scrollX} ${scrollY}`);\n            }\n            try {\n                const { params } = match(route.originalPath, {\n                    decode: decodeURIComponent,\n                })(to);\n                const allParams = {\n                    ...Router.getParams(),\n                    ...Object.fromEntries(Object.entries(params)\n                        .map((pair) => Number.isNaN(Number(pair[0])) && pair)\n                        .filter(Boolean)),\n                };\n                const props = {\n                    from: from.replace(base, \"\"),\n                    to: to.replace(base, \"\"),\n                    ...(Object.keys(allParams).length ? { params: allParams } : {}),\n                    ...(history.state && Object.keys(history.state).length\n                        ? { state: history.state }\n                        : {}),\n                };\n                // Trigger leave\n                if (this.oldRoute) {\n                    const oldRoute = this.routes.find((route) => route.path.exec(this.oldRoute));\n                    if (oldRoute) {\n                        await oldRoute[\"leave\" /* cycles.leave */]?.(props);\n                        this.oldRoute = route.originalPath;\n                    }\n                }\n                // Trigger beforeEnter\n                await route[\"beforeEnter\" /* cycles.beforeEnter */]?.(props);\n                // Handle template / element\n                if (!!route.isChildOf) {\n                    setReuseElements(false);\n                    const parent = route.isChildOf;\n                    if (parent.templateUrl) {\n                        await handleTemplate(parent, $(outletSelector));\n                    }\n                    else if (parent.element) {\n                        const copy = $(outletSelector).cloneNode();\n                        copy.append(html `${parent.element}`);\n                        render(copy, outletSelector, false);\n                    }\n                    setReuseElements(true);\n                }\n                const where = route.isChildOf\n                    ? $(outletSelector).querySelector(outletSelector)\n                    : $(outletSelector);\n                if (route?.templateUrl) {\n                    await handleTemplate(route, where);\n                }\n                else if (route?.element) {\n                    const copy = where.cloneNode();\n                    copy.append(html `${route.element}`);\n                    render(copy, where, false);\n                }\n                else {\n                    // Clear outlet\n                    $(outletSelector).textContent = null;\n                }\n                currStorageKey = `${storageKey}-${to}`;\n                // Trigger afterEnter\n                await route[\"afterEnter\" /* cycles.afterEnter */]?.(props);\n            }\n            catch (err) {\n                if (this.options.errorHandler) {\n                    await this.options.errorHandler(err, e);\n                }\n                else {\n                    console.error(err, e);\n                }\n            }\n            finally {\n                // Reload -> restore scroll position\n                if (route.restoreScroll && sessionStorage.getItem(currStorageKey)) {\n                    const [left, top] = sessionStorage\n                        .getItem(currStorageKey)\n                        .split(\" \")\n                        .map(Number);\n                    sessionStorage.removeItem(currStorageKey);\n                    scrollTo({\n                        top,\n                        left,\n                        behavior: this.options.scrollBehavior || \"auto\",\n                    });\n                }\n                else {\n                    // Reset Scroll, just like Browser\n                    if (!window.isHMR) {\n                        scrollTo({\n                            top: 0,\n                            left: 0,\n                            behavior: this.options.scrollBehavior || \"auto\",\n                        });\n                    }\n                }\n                dispatchEvent(new Event(\"afterRouting\"));\n            }\n        }\n    }\n    go(path, state, params = \"\") {\n        this.oldRoute = location.pathname + location.search;\n        const newPath = base + path + params;\n        // Only navigate when the path differs\n        if (newPath !== this.oldRoute) {\n            history.pushState({ ...state }, \"\", newPath);\n            this.doRouting(newPath);\n        }\n    }\n    removeRoute(path) {\n        const idx = this.routes.findIndex((route) => String(route.path) === String(pathToRegexp(path)));\n        if (idx > -1) {\n            this.routes.splice(idx, 1);\n        }\n    }\n    addRoute(route) {\n        this.routes.push({\n            ...route,\n            path: pathToRegexp(base + route.path),\n            originalPath: base + route.path,\n        });\n    }\n    modifyRoute(path, newRoute) {\n        const idx = this.routes.findIndex((route) => String(route.path) === String(pathToRegexp(path)));\n        if (idx > -1) {\n            this.routes[idx] = {\n                ...newRoute,\n                path: pathToRegexp(base + newRoute.path),\n                originalPath: base + path,\n            };\n        }\n    }\n    changeOptions(options) {\n        this.options = options;\n    }\n    static getParams(search = location.search) {\n        return Object.fromEntries(new URLSearchParams(search));\n    }\n}\nfunction registerAnchorEvent(anchor) {\n    if (anchor.getAttribute(\"href\")?.startsWith(\"http\"))\n        return;\n    anchor.addEventListener(\"click\", (e) => {\n        e.preventDefault();\n        const hasData = anchor.getAttribute(\"data\");\n        const hydroProp = replaceBars(hasData);\n        const href = anchor.getAttribute(\"href\") || \"\";\n        router.go(href, hasData ? hydro[hydroProp] : void 0);\n    });\n}\nfunction registerFormEvent(form) {\n    form.addEventListener(\"submit\", (e) => {\n        if (!router.options.formHandler)\n            return;\n        e.preventDefault();\n        const action = form.getAttribute(\"action\");\n        const method = form.getAttribute(\"method\");\n        fetch(action, {\n            method,\n            ...(![\"HEAD\", \"GET\"].includes(method.toUpperCase())\n                ? { body: new FormData(form) }\n                : {}),\n            ...router.options.fetchOptions,\n        })\n            .then((res) => router.options.formHandler(res, e))\n            .catch(async (err) => {\n            if (router.options.errorHandler) {\n                await router.options.errorHandler(err, e);\n            }\n            else {\n                console.error(err, e);\n            }\n        });\n    });\n}\nfunction replaceBars(hydroTerm) {\n    if (hydroTerm === null || !hydroTerm.includes(\"{{\"))\n        return hydroTerm;\n    const [_, hydroPath] = hydroTerm.match(reactivityRegex) || [];\n    return hydroPath;\n}\n// Add EventListener for every added anchor and form Element\n$$(\"a\").forEach(registerAnchorEvent);\n$$(\"form\").forEach(registerFormEvent);\nnew MutationObserver((entries) => {\n    for (const entry of entries) {\n        for (const node of entry.addedNodes) {\n            const nodes = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT, {\n                acceptNode(elem) {\n                    return [\"form\", \"a\"].includes(elem.localName)\n                        ? NodeFilter.FILTER_ACCEPT\n                        : NodeFilter.FILTER_REJECT;\n                },\n            });\n            let formOrA;\n            while ((formOrA = nodes.nextNode())) {\n                if (formOrA.localName === \"a\") {\n                    registerAnchorEvent(formOrA);\n                }\n                else {\n                    registerFormEvent(formOrA);\n                }\n            }\n        }\n    }\n}).observe(document.body, { childList: true, subtree: true });\nasync function handleTemplate(route, where) {\n    let cacheObj = fetchCache.get(route);\n    if (!fetchCache.has(route) || cacheObj?.promise === null) {\n        cacheObj?.controller?.abort();\n        const data = await fetch(route.templateUrl);\n        if (!cacheObj) {\n            cacheObj = {\n                html: await data.text(),\n            };\n            fetchCache.set(route, cacheObj);\n        }\n        else {\n            cacheObj.html = await data.text();\n        }\n    }\n    Reflect.deleteProperty(cacheObj, \"controller\");\n    const copy = where.cloneNode();\n    copy.append(window.isHMR || !cacheObj?.hasOwnProperty(\"html\")\n        ? html `${await (await fetch(route.templateUrl)).text()}`\n        : html `${(await cacheObj.html) || \"\"}`);\n    render(copy, where, false);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}