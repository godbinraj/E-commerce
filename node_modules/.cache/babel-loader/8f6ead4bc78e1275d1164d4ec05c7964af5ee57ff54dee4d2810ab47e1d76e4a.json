{"ast":null,"code":"// Safari Polyfills\nwindow.requestIdleCallback = /* c8 ignore next 4 */\nwindow.requestIdleCallback || ((cb, _, start = performance.now()) => setTimeout(cb, 0, {\n  didTimeout: false,\n  timeRemaining: () => Math.max(0, 5 - (performance.now() - start))\n}));\n// Safari Polyfills END\nconst range = document.createRange();\nrange.selectNodeContents(range.createContextualFragment(`<${\"template\" /* Placeholder.template */}>`).lastChild);\nconst parser = range.createContextualFragment.bind(range);\nconst allNodeChanges = new WeakMap(); // Maps a Node against an array of changes. An array is necessary because a node can have multiple variables for one text / attribute.\nconst elemEventFunctions = new WeakMap(); // Stores event functions in order to compare Elements against each other.\nconst reactivityMap = new WeakMap(); // Maps Proxy Objects to another Map(proxy-key, node).\nconst bindMap = new WeakMap(); // Bind an Element to data. If the data is being unset, the DOM Element disappears too.\nconst tmpSwap = new WeakMap(); // Take over keyToNodeMap if the new value is a hydro Proxy. Save old reactivityMap entry here, in case for a swap operation.\nconst onRenderMap = new WeakMap(); // Lifecycle Hook that is being called after rendering\nconst onCleanupMap = new WeakMap(); // Lifecycle Hook that is being called when unmount function is being called\nconst fragmentToElements = new WeakMap(); // Used to retreive Elements from DocumentFragment after it has been rendered â€“ for diffing\nconst hydroToReactive = new WeakMap(); // Used for internal mapping from hydroKeys to the the Proxy created by the reactive function\nconst _boundFunctions = Symbol(\"boundFunctions\"); // Cache for bound functions in Proxy, so that we create the bound version of each function only once\nconst reactiveSymbol = Symbol(\"reactive\");\nconst keysSymbol = Symbol(\"keys\");\nlet globalSchedule = true; // Decides whether to schedule rendering and updating (async)\nlet reuseElements = true; // Reuses Elements when rendering\nlet insertBeforeDiffing = false; // Makes sense in Chrome only\nlet shouldSetReactivity = true;\nlet viewElements = false;\nlet ignoreIsConnected = false;\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst HTML_FIND_INVALID = /<(\\/?)(html|head|body)(>|\\s.*?>)/g;\nconst newLineRegex = /\\n/g;\nconst propChainRegex = /[\\.\\[\\]]/;\nconst onEventRegex = /^on/;\n// https://html.spec.whatwg.org/#attributes-3\n// if value for bool attr is falsy, then remove attr\n// INFO: draggable and spellcheck are actually using booleans as string! Also, hidden is not really a bool attr, but is making use of the empty string too. Might consider to add 'translate' (yes and no as string)\nconst boolAttrList = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"draggable\", \"default\", \"defer\", \"disabled\", \"formnovalidate\", \"hidden\", \"inert\", \"ismap\", \"itemscope\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"selected\", \"spellcheck\"];\nlet lastSwapElem = null;\nlet internReset = false;\nfunction isObject(obj) {\n  return obj != null && typeof obj === \"object\";\n}\nfunction isFunction(func) {\n  return typeof func === \"function\" /* Placeholder.function */;\n}\nfunction isTextNode(node) {\n  return node.splitText !== undefined;\n}\nfunction isNode(node) {\n  return node instanceof Node;\n}\nfunction isDocumentFragment(node) {\n  return node.nodeType === 11;\n}\nfunction isEventObject(obj) {\n  return isObject(obj) && \"event\" /* Placeholder.event */ in obj && \"options\" /* Placeholder.options */ in obj;\n}\nfunction isProxy(hydroObject) {\n  return Reflect.get(hydroObject, \"isProxy\" /* Placeholder.isProxy */);\n}\nfunction isPromise(obj) {\n  return isObject(obj) && typeof obj.then === \"function\";\n}\nfunction randomText() {\n  const randomChars = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n  let result = \"\";\n  for (var i = 0; i < 6; i++) {\n    result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n  }\n  return result;\n  // return Math.random().toString(32).slice(2);\n}\nfunction setGlobalSchedule(willSchedule) {\n  globalSchedule = willSchedule;\n  setHydroRecursive(hydro);\n}\nfunction setReuseElements(willReuse) {\n  reuseElements = willReuse;\n}\nfunction setInsertDiffing(willInsert) {\n  insertBeforeDiffing = willInsert;\n}\nfunction setShouldSetReactivity(willSet) {\n  shouldSetReactivity = willSet;\n}\nfunction setIgnoreIsConnected(ignore) {\n  ignoreIsConnected = ignore;\n}\nfunction setHydroRecursive(obj) {\n  Reflect.set(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */, globalSchedule);\n  for (const value of Object.values(obj)) {\n    if (isObject(value) && isProxy(value)) {\n      setHydroRecursive(value);\n    }\n  }\n}\nfunction setAttribute(node, key, val) {\n  const isBoolAttr = boolAttrList.includes(key);\n  if (isBoolAttr && !val) {\n    node.removeAttribute(key);\n    return false;\n  }\n  node.setAttribute(key, isFunction(val) && Reflect.has(val, reactiveSymbol) ? val : isBoolAttr ? \"\" : val);\n  return true;\n}\nfunction addEventListener(node, eventName, obj) {\n  node.addEventListener(eventName, isFunction(obj) ? obj : obj.event, isFunction(obj) ? {} : obj.options);\n}\nfunction html(htmlArray, ...variables) {\n  const eventFunctions = {}; // Temporarily store a mapping for string -> function, because eventListener have to be registered after the Element's creation\n  let insertNodes = []; // Nodes, that will be added after the parsing\n  const resolvedVariables = [];\n  for (const variable of variables) {\n    const template = `<${\"template\" /* Placeholder.template */} id=\"lbInsertNodes\"></${\"template\" /* Placeholder.template */}>`;\n    if (isNode(variable)) {\n      insertNodes.push(variable);\n      resolvedVariables.push(template);\n    } else if ([\"number\", \"string\" /* Placeholder.string */, \"symbol\", \"boolean\", \"bigint\"].includes(typeof variable) || Reflect.has(variable, reactiveSymbol)) {\n      resolvedVariables.push(String(variable));\n    } else if (isFunction(variable) || isEventObject(variable)) {\n      const funcName = randomText();\n      Reflect.set(eventFunctions, funcName, variable);\n      resolvedVariables.push(funcName);\n    } else if (Array.isArray(variable)) {\n      for (let index = 0; index < variable.length; index++) {\n        const item = variable[index];\n        if (isNode(item)) {\n          insertNodes.push(item);\n          variable[index] = template;\n        }\n      }\n      resolvedVariables.push(variable.join(\"\"));\n    } else if (isObject(variable)) {\n      let result = \"\";\n      for (const [key, value] of Object.entries(variable)) {\n        if (isFunction(value) || isEventObject(value)) {\n          const funcName = randomText();\n          Reflect.set(eventFunctions, funcName, value);\n          result += `${key}=\"${funcName}\"`;\n        } else {\n          result += `${key}=\"${value}\"`;\n        }\n      }\n      resolvedVariables.push(result);\n    }\n  }\n  // Find elements <html|head|body>, as they cannot be created by the parser. Replace them by fake Custom Elements and replace them afterwards.\n  let DOMString = String.raw(htmlArray, ...resolvedVariables).trim();\n  DOMString = DOMString.replace(HTML_FIND_INVALID, `<$1$2${\"-dummy\" /* Placeholder.dummy */}$3`);\n  const DOM = parser(DOMString);\n  // Delay Element iteration and manipulation after the elements have been added to the DOM.\n  if (!viewElements) {\n    fillDOM(DOM, insertNodes, eventFunctions);\n  }\n  // Return DocumentFragment\n  if (DOM.childNodes.length > 1) return DOM;\n  // Return empty Text Node\n  if (!DOM.firstChild) return document.createTextNode(\"\");\n  // Return Element | Text\n  return DOM.firstChild;\n}\nfunction fillDOM(elem, insertNodes, eventFunctions) {\n  const root = document.createNodeIterator(elem, NodeFilter.SHOW_ELEMENT, {\n    acceptNode(element) {\n      return element.localName.endsWith(\"-dummy\" /* Placeholder.dummy */) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;\n    }\n  });\n  let nextNode;\n  while (nextNode = root.nextNode()) {\n    const tag = nextNode.localName.replace(\"-dummy\" /* Placeholder.dummy */, \"\");\n    const replacement = document.createElement(tag);\n    replacement.append(...nextNode.childNodes);\n    /* c8 ignore next 3 */\n    for (const key of nextNode.getAttributeNames()) {\n      replacement.setAttribute(key, nextNode.getAttribute(key));\n    }\n    nextNode.replaceWith(replacement);\n  }\n  // Insert HTML Elements, which were stored in insertNodes\n  if (!isTextNode(elem)) {\n    for (const template of elem.querySelectorAll(\"template[id^=lbInsertNodes]\")) template.replaceWith(insertNodes.shift());\n  }\n  if (shouldSetReactivity) setReactivity(elem, eventFunctions);\n}\nfunction h(name, props, ...children) {\n  if (isFunction(name)) return name({\n    ...props,\n    children\n  });\n  const elem = typeof name === \"string\" /* Placeholder.string */ ? document.createElement(name, props?.hasOwnProperty(\"is\") ? {\n    is: props[\"is\"]\n  } : undefined) : document.createDocumentFragment();\n  for (let i in props) {\n    i in elem && !boolAttrList.includes(i) ?\n    //@ts-ignore\n    elem[i] = props[i] : setAttribute(elem, i, props[i]);\n  }\n  if (isDocumentFragment(elem)) {\n    children = name.children;\n  }\n  elem.append(...(children.some(i => Array.isArray(i)) ? children.map(getChildren).flat() : children));\n  if (!viewElements) {\n    setReactivity(elem);\n  }\n  return elem;\n}\nfunction getChildren(child) {\n  return isObject(child) && !isNode(child) ? Object.values(child) : child;\n}\n/* c8 ignore end */\nfunction setReactivity(DOM, eventFunctions) {\n  if (isTextNode(DOM)) {\n    setReactivitySingle(DOM);\n    return;\n  }\n  const elems = document.createNodeIterator(DOM, NodeFilter.SHOW_ELEMENT);\n  let elem;\n  while (elem = elems.nextNode()) {\n    for (const key of elem.getAttributeNames()) {\n      // Set functions\n      const val = elem.getAttribute(key);\n      if (eventFunctions && key.startsWith(\"on\")) {\n        const eventName = key.replace(onEventRegex, \"\");\n        const event = eventFunctions[val];\n        if (!event) {\n          setReactivitySingle(elem, key, val);\n          continue;\n        }\n        elem.removeAttribute(key);\n        if (isEventObject(event)) {\n          elem.addEventListener(eventName, event.event, event.options);\n          if (elemEventFunctions.has(elem)) {\n            elemEventFunctions.get(elem).push(event.event);\n          } else {\n            elemEventFunctions.set(elem, [event.event]);\n          }\n        } else {\n          elem.addEventListener(eventName, event);\n          if (elemEventFunctions.has(elem)) {\n            elemEventFunctions.get(elem).push(event);\n          } else {\n            elemEventFunctions.set(elem, [event]);\n          }\n        }\n      } else {\n        setReactivitySingle(elem, key, val);\n      }\n    }\n    let childNode = elem.firstChild;\n    while (childNode) {\n      if (isTextNode(childNode) && childNode.nodeValue?.includes(\"{{\")) {\n        setReactivitySingle(childNode);\n      }\n      childNode = childNode.nextSibling;\n    }\n  }\n}\nfunction setReactivitySingle(node, key, val) {\n  let attr_OR_text, match;\n  if (!key) {\n    attr_OR_text = node.nodeValue; // nodeValue is (always) defined on Text Nodes\n  } else {\n    attr_OR_text = val;\n    if (attr_OR_text === \"\") {\n      // e.g. checked attribute or two-way attribute\n      attr_OR_text = key;\n      if (attr_OR_text.startsWith(\"{{\")) {\n        node.removeAttribute(attr_OR_text);\n      }\n    }\n  }\n  while (match = attr_OR_text.match(reactivityRegex)) {\n    // attr_OR_text will be altered in every iteration\n    const [hydroMatch, hydroPath] = match;\n    const properties = hydroPath.trim().replace(newLineRegex, \"\").split(propChainRegex).filter(Boolean);\n    const [resolvedValue, resolvedObj] = resolveObject(properties);\n    let lastProp = properties[properties.length - 1];\n    const start = match.index;\n    let end = start + String(resolvedValue).length;\n    if (isNode(resolvedValue)) {\n      node.nodeValue = attr_OR_text.replace(hydroMatch, \"\");\n      node.after(resolvedValue);\n      setTraces(start, end, resolvedValue, lastProp, resolvedObj, key);\n      return;\n    }\n    // Set Text or set Attribute\n    if (isTextNode(node)) {\n      const textContent = isObject(resolvedValue) ? JSON.stringify(resolvedValue) : resolvedValue ?? \"\";\n      attr_OR_text = attr_OR_text.replace(hydroMatch, textContent);\n      if (attr_OR_text != null) {\n        node.nodeValue = attr_OR_text;\n      }\n    } else {\n      if (key === \"bind\") {\n        attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n        node.removeAttribute(key);\n        const proxy = isObject(resolvedValue) && isProxy(resolvedValue) ? resolvedValue : resolvedObj;\n        if (bindMap.has(proxy)) {\n          bindMap.get(proxy).push(node);\n        } else {\n          bindMap.set(proxy, [node]);\n        }\n        continue;\n      } else if (key === \"two-way\" /* Placeholder.twoWay */) {\n        if (node instanceof HTMLSelectElement) {\n          node.value = resolvedValue;\n          changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp);\n        } else if (node instanceof HTMLInputElement && node.type === \"radio\" /* Placeholder.radio */) {\n          node.checked = node.value === resolvedValue;\n          changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp);\n        } else if (node instanceof HTMLInputElement && node.type === \"checkbox\" /* Placeholder.checkbox */) {\n          node.checked = resolvedValue;\n          changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp, true);\n        } else if (node instanceof HTMLTextAreaElement || node instanceof HTMLInputElement) {\n          node.value = resolvedValue;\n          changeAttrVal(\"input\", node, resolvedObj, lastProp);\n        }\n        attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n        node.toggleAttribute(\"two-way\" /* Placeholder.twoWay */);\n      } else if (isFunction(resolvedValue) || isEventObject(resolvedValue)) {\n        attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n        node.removeAttribute(key);\n        addEventListener(node, key.replace(onEventRegex, \"\"), resolvedValue);\n      } else if (isObject(resolvedValue)) {\n        // Case: setting attrs on Element - <p ${props}>\n        for (const [subKey, subVal] of Object.entries(resolvedValue)) {\n          attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n          if (isFunction(subVal) || isEventObject(subVal)) {\n            addEventListener(node, subKey.replace(onEventRegex, \"\"), subVal);\n          } else {\n            lastProp = subKey;\n            if (setAttribute(node, subKey, subVal)) {\n              end = start + String(subVal).length;\n            } else {\n              end = start;\n            }\n          }\n          setTraces(start, end, node, lastProp, resolvedValue, subKey);\n        }\n        continue; // As we set all Mappings via subKeys\n      } else {\n        attr_OR_text = attr_OR_text.replace(hydroMatch, resolvedValue);\n        if (!setAttribute(node, key, attr_OR_text === String(resolvedValue) ? resolvedValue : attr_OR_text)) {\n          attr_OR_text = attr_OR_text.replace(resolvedValue, \"\");\n        }\n      }\n    }\n    setTraces(start, end, node, lastProp, resolvedObj, key);\n  }\n}\n// Same behavior as v-model in https://v3.vuejs.org/guide/forms.html#basic-usage\nfunction changeAttrVal(eventName, node, resolvedObj, lastProp, isChecked = false) {\n  node.addEventListener(eventName, changeHandler);\n  onCleanup(() => node.removeEventListener(eventName, changeHandler), node);\n  function changeHandler({\n    target\n  }) {\n    Reflect.set(resolvedObj, lastProp, isChecked ? target.checked : target.value);\n  }\n}\nfunction setTraces(start, end, node, hydroKey, resolvedObj, key) {\n  // Set WeakMaps, that will be used to track a change for a Node but also to check if a Node has any other changes.\n  const change = [start, end, key, resolvedObj];\n  const changeArr = [change];\n  if (allNodeChanges.has(node)) {\n    allNodeChanges.get(node).push(change);\n  } else {\n    allNodeChanges.set(node, [change]); // Use own version. Otherwise changes, will lead to incorrect changes in the DOM.\n  }\n  if (reactivityMap.has(resolvedObj)) {\n    const keyToNodeMap = reactivityMap.get(resolvedObj);\n    const nodeToChangeMap = keyToNodeMap.get(hydroKey);\n    if (nodeToChangeMap) {\n      if (nodeToChangeMap.has(node)) {\n        nodeToChangeMap.get(node).push(change);\n      } else {\n        nodeToChangeMap.set(changeArr, node);\n        nodeToChangeMap.set(node, changeArr);\n      }\n    } else {\n      keyToNodeMap.set(hydroKey,\n      //@ts-ignore\n      new Map([[changeArr, node], [node, changeArr]]));\n    }\n  } else {\n    reactivityMap.set(resolvedObj, new Map([[hydroKey,\n    //@ts-ignore\n    new Map([[changeArr, node], [node, changeArr]])]]));\n  }\n}\n// Helper function to return a value and hydro obj from a chain of properties\nfunction resolveObject(propertyArray) {\n  let value, prev;\n  value = prev = hydro;\n  for (const prop of propertyArray) {\n    prev = value;\n    value = Reflect.get(prev, prop);\n  }\n  return [value, prev];\n}\nfunction compareEvents(elem, where, onlyTextChildren) {\n  const elemFunctions = [];\n  const whereFunctions = [];\n  if (isTextNode(elem)) {\n    if (onRenderMap.has(elem)) {\n      elemFunctions.push(onRenderMap.get(elem));\n    }\n    if (onCleanupMap.has(elem)) {\n      elemFunctions.push(onCleanupMap.get(elem));\n    }\n    if (onRenderMap.has(where)) {\n      whereFunctions.push(onRenderMap.get(where));\n    }\n    if (onCleanupMap.has(where)) {\n      whereFunctions.push(onCleanupMap.get(where));\n    }\n    if (elemFunctions.length !== whereFunctions.length) return false;\n    if (String(elemFunctions) !== String(whereFunctions)) return false;\n    return true;\n  }\n  if (elemEventFunctions.has(elem)) {\n    elemFunctions.push(...elemEventFunctions.get(elem));\n  }\n  if (elemEventFunctions.has(where)) {\n    whereFunctions.push(...elemEventFunctions.get(where));\n  }\n  if (onRenderMap.has(elem)) {\n    elemFunctions.push(onRenderMap.get(elem));\n  }\n  if (onCleanupMap.has(elem)) {\n    elemFunctions.push(onCleanupMap.get(elem));\n  }\n  if (onRenderMap.has(where)) {\n    whereFunctions.push(onRenderMap.get(where));\n  }\n  if (onCleanupMap.has(where)) {\n    whereFunctions.push(onCleanupMap.get(where));\n  }\n  if (elemFunctions.length !== whereFunctions.length) return false;\n  if (String(elemFunctions) !== String(whereFunctions)) return false;\n  for (let i = 0; i < elem.childNodes.length; i++) {\n    if (onlyTextChildren) {\n      if (isTextNode(elem.childNodes[i])) {\n        if (!compareEvents(elem.childNodes[i], where.childNodes[i], onlyTextChildren)) {\n          return false;\n        }\n      }\n    } else {\n      if (!compareEvents(elem.childNodes[i], where.childNodes[i])) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nfunction compare(elem, where, onlyTextChildren) {\n  if (isDocumentFragment(elem) || isDocumentFragment(where)) return false;\n  return elem.isEqualNode(where) && compareEvents(elem, where, onlyTextChildren);\n}\nfunction render(elem, where = \"\", shouldSchedule = globalSchedule) {\n  /* c8 ignore next 4 */\n  if (shouldSchedule) {\n    schedule(render, elem, where, false);\n    return unmount(elem);\n  }\n  // Get elem value if elem is reactiveObject\n  if (Reflect.has(elem, reactiveSymbol)) {\n    elem = getValue(elem);\n  }\n  // Store elements of documentFragment for later unmount\n  let elemChildren = [];\n  if (isDocumentFragment(elem)) {\n    elemChildren = Array.from(elem.childNodes);\n    fragmentToElements.set(elem, elemChildren); // For diffing later\n  }\n  if (!where) {\n    document.body.append(elem);\n  } else {\n    if (typeof where === \"string\" /* Placeholder.string */) {\n      const resolveStringToElement = $(where);\n      if (resolveStringToElement) {\n        where = resolveStringToElement;\n      } else {\n        return noop;\n      }\n    }\n    if (!reuseElements) {\n      replaceElement(elem, where);\n    } else {\n      if (isTextNode(elem)) {\n        replaceElement(elem, where);\n      } else if (!compare(elem, where)) {\n        treeDiff(elem, where);\n      }\n    }\n  }\n  runLifecyle(elem, onRenderMap);\n  for (const subElem of elemChildren) {\n    runLifecyle(subElem, onRenderMap);\n  }\n  return unmount(isDocumentFragment(elem) ? elemChildren : elem);\n}\nfunction noop() {}\nfunction executeLifecycle(node, lifecyleMap) {\n  if (lifecyleMap.has(node)) {\n    const fn = lifecyleMap.get(node);\n    if (globalSchedule) {\n      schedule(fn);\n    } else {\n      fn();\n    }\n    lifecyleMap.delete(node);\n  }\n}\nfunction runLifecyle(node, lifecyleMap) {\n  if (lifecyleMap === onRenderMap && !calledOnRender || lifecyleMap === onCleanupMap && !calledOnCleanup) return;\n  executeLifecycle(node, lifecyleMap);\n  const elements = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n  let subElem;\n  while (subElem = elements.nextNode()) {\n    executeLifecycle(subElem, lifecyleMap);\n    let childNode = subElem.firstChild;\n    while (childNode) {\n      if (isTextNode(childNode)) {\n        executeLifecycle(childNode, lifecyleMap);\n      }\n      childNode = childNode.nextSibling;\n    }\n  }\n}\nfunction filterTag2Elements(tag2Elements, root) {\n  for (const [localName, list] of tag2Elements.entries()) {\n    for (let i = 0; i < list.length; i++) {\n      const elem = list[i];\n      if (root.contains(elem) || root.isSameNode(elem)) {\n        list.splice(i, 1);\n        i--;\n      }\n      if (list.length === 0) {\n        tag2Elements.delete(localName);\n      }\n    }\n  }\n}\nfunction treeDiff(elem, where) {\n  let elemElements = [...elem.querySelectorAll(\"*\")];\n  if (!isDocumentFragment(elem)) elemElements.unshift(elem);\n  let whereElements = [];\n  if (!isTextNode(where)) {\n    whereElements = [...where.querySelectorAll(\"*\")];\n    if (!isDocumentFragment(where)) whereElements.unshift(where);\n  }\n  let template;\n  if (insertBeforeDiffing) {\n    template = document.createElement(\"template\" /* Placeholder.template */);\n    /* c8 ignore next 3 */\n    if (where === document.documentElement) {\n      where.append(template);\n    } else {\n      if (isDocumentFragment(where)) {\n        fragmentToElements.get(where)[0].before(template);\n      } else {\n        where.before(template);\n      }\n    }\n    template.append(elem);\n  }\n  // Create Mapping for easier diffing, eg: \"div\" -> [...Element]\n  const tag2Elements = new Map();\n  for (const wElem of whereElements) {\n    /* c8 ignore next 2 */\n    if (insertBeforeDiffing && wElem === template) return;\n    if (tag2Elements.has(wElem.localName)) {\n      tag2Elements.get(wElem.localName).push(wElem);\n    } else {\n      tag2Elements.set(wElem.localName, [wElem]);\n    }\n  }\n  // Re-use any where Element if possible, then remove elem Element\n  for (const subElem of elemElements) {\n    const sameElements = tag2Elements.get(subElem.localName);\n    if (sameElements) {\n      for (const whereElem of sameElements) {\n        if (compare(subElem, whereElem, true)) {\n          subElem.replaceWith(whereElem);\n          runLifecyle(subElem, onCleanupMap);\n          filterTag2Elements(tag2Elements, whereElem);\n          break;\n        }\n      }\n    }\n  }\n  if (insertBeforeDiffing) {\n    const newElems = isDocumentFragment(elem) ? Array.from(template.childNodes) : [elem];\n    if (isDocumentFragment(where)) {\n      const oldElems = fragmentToElements.get(where);\n      for (const e of newElems) oldElems[0].before(e);\n      for (const e of oldElems) e.remove();\n    } else {\n      where.replaceWith(...newElems);\n    }\n    template.remove();\n    runLifecyle(where, onCleanupMap);\n  } else {\n    replaceElement(elem, where);\n  }\n  tag2Elements.clear();\n}\nfunction replaceElement(elem, where) {\n  if (isDocumentFragment(where)) {\n    const fragmentChildren = fragmentToElements.get(where);\n    if (isDocumentFragment(elem)) {\n      const fragmentElements = Array.from(elem.childNodes);\n      for (let index = 0; index < fragmentChildren.length; index++) {\n        const fragWhere = fragmentChildren[index];\n        if (index < fragmentElements.length) {\n          render(fragmentElements[index], fragWhere);\n        } else {\n          fragWhere.remove();\n        }\n      }\n    } else {\n      for (let index = 0; index < fragmentChildren.length; index++) {\n        const fragWhere = fragmentChildren[index];\n        if (index === 0) {\n          render(elem, fragWhere);\n        } else {\n          fragWhere.remove();\n        }\n      }\n    }\n  } else {\n    where.replaceWith(elem);\n  }\n  runLifecyle(where, onCleanupMap);\n}\nfunction unmount(elem) {\n  if (Array.isArray(elem)) {\n    return () => elem.forEach(removeElement);\n  } else {\n    return () => removeElement(elem);\n  }\n}\nfunction removeElement(elem) {\n  if (!ignoreIsConnected && elem.isConnected) {\n    elem.remove();\n    runLifecyle(elem, onCleanupMap);\n  }\n}\n/* c8 ignore next 13 */\nasync function schedule(fn, ...args) {\n  if (\"scheduler\" in window) {\n    // @ts-ignore\n    scheduler.postTask(fn.bind(fn, ...args), {\n      priority: \"background\"\n    });\n  } else {\n    window.requestIdleCallback(() => fn(...args));\n  }\n}\nfunction reactive(initial) {\n  let key;\n  do key = randomText(); while (Reflect.has(hydro, key));\n  Reflect.set(hydro, key, initial);\n  Reflect.set(setter, reactiveSymbol, true);\n  const chainKeysProxy = chainKeys(setter, [key]);\n  if (isObject(initial)) {\n    hydroToReactive.set(Reflect.get(hydro, key), chainKeysProxy);\n  }\n  return chainKeysProxy;\n  function setter(val) {\n    const keys =\n    // @ts-ignore\n    (this && Reflect.has(this, reactiveSymbol) ? this : chainKeysProxy)[keysSymbol.description];\n    const [resolvedValue, resolvedObj] = resolveObject(keys);\n    const lastProp = keys[keys.length - 1];\n    if (isFunction(val)) {\n      const returnVal = val(resolvedValue);\n      const sameObject = resolvedValue === returnVal;\n      if (sameObject) return;\n      Reflect.set(resolvedObj, lastProp, returnVal ?? resolvedValue);\n    } else {\n      Reflect.set(resolvedObj, lastProp, val);\n    }\n  }\n}\nfunction chainKeys(initial, keys) {\n  return new Proxy(initial, {\n    get(target, subKey, _receiver) {\n      if (subKey === reactiveSymbol.description) return true;\n      if (subKey === keysSymbol.description) {\n        return keys;\n      }\n      if (subKey === Symbol.toPrimitive) {\n        return () => `{{${keys.join(\".\")}}}`;\n      }\n      return chainKeys(target, [...keys, subKey]);\n    }\n  });\n}\nfunction getReactiveKeys(reactiveHydro) {\n  const keys = reactiveHydro[keysSymbol.description];\n  const lastProp = keys[keys.length - 1];\n  return [lastProp, keys.length === 1];\n}\nfunction unset(reactiveHydro) {\n  const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n  if (oneKey) {\n    Reflect.set(hydro, lastProp, null);\n    if (hydroToReactive.has(hydro[lastProp])) {\n      hydroToReactive.delete(hydro[lastProp]);\n    }\n  } else {\n    const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n    Reflect.set(resolvedObj, lastProp, null);\n  }\n}\nfunction setAsyncUpdate(reactiveHydro, asyncUpdate) {\n  const [_, oneKey] = getReactiveKeys(reactiveHydro);\n  if (oneKey) {\n    hydro.asyncUpdate = asyncUpdate;\n  } else {\n    const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n    resolvedObj.asyncUpdate = asyncUpdate;\n  }\n}\nfunction observe(reactiveHydro, fn) {\n  const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n  if (oneKey) {\n    hydro.observe(lastProp, fn);\n  } else {\n    const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n    resolvedObj.observe(lastProp, fn);\n  }\n}\nfunction unobserve(reactiveHydro) {\n  const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n  if (oneKey) {\n    hydro.unobserve(lastProp);\n  } else {\n    const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n    resolvedObj.unobserve(lastProp);\n  }\n}\nfunction ternary(condition, trueVal, falseVal, reactiveHydro = condition) {\n  const checkCondition = cond => (!Reflect.has(condition, reactiveSymbol) && isFunction(condition) ? condition(cond) : isPromise(cond) ? false : cond) ? isFunction(trueVal) ? trueVal() : trueVal : isFunction(falseVal) ? falseVal() : falseVal;\n  const ternaryValue = reactive(checkCondition(getValue(reactiveHydro)));\n  observe(reactiveHydro, newVal => {\n    newVal === null ? unset(ternaryValue) : ternaryValue(checkCondition(newVal));\n  });\n  return ternaryValue;\n}\nfunction emit(eventName, data, who, options = {\n  bubbles: true\n}) {\n  who.dispatchEvent(new CustomEvent(eventName, {\n    ...options,\n    detail: data\n  }));\n}\nlet trackDeps = false;\nconst trackProxies = new Set();\nconst trackMap = new WeakMap();\nconst unobserveMap = new WeakMap();\nfunction watchEffect(fn) {\n  trackDeps = true;\n  fn();\n  trackDeps = false;\n  const reRun = newVal => {\n    if (newVal !== null) fn();\n  };\n  for (const proxy of trackProxies) {\n    if (!trackMap.has(proxy)) continue;\n    for (const key of trackMap.get(proxy)) {\n      proxy.observe(key, reRun);\n      if (unobserveMap.has(reRun)) {\n        unobserveMap.get(reRun).push({\n          proxy,\n          key\n        });\n      } else {\n        unobserveMap.set(reRun, [{\n          proxy,\n          key\n        }]);\n      }\n    }\n    trackMap.delete(proxy);\n  }\n  trackProxies.clear();\n  return () => unobserveMap.get(reRun).forEach(entry => entry.proxy.unobserve(entry.key, reRun));\n}\nfunction getValue(reactiveHydro) {\n  const [resolvedValue] = resolveObject(Reflect.get(reactiveHydro, keysSymbol.description));\n  return resolvedValue;\n}\nlet calledOnRender = false;\nfunction onRender(fn, elem, ...args) {\n  calledOnRender = true;\n  onRenderMap.set(elem, args.length ? fn.bind(fn, ...args) : fn);\n}\nlet calledOnCleanup = false;\nfunction onCleanup(fn, elem, ...args) {\n  calledOnCleanup = true;\n  onCleanupMap.set(elem, args.length ? fn.bind(fn, ...args) : fn);\n}\n// Core of the library\nfunction generateProxy(obj) {\n  const handlers = Symbol(\"handlers\"); // For observer pattern\n  const boundFunctions = new WeakMap();\n  const proxy = new Proxy(obj ?? {}, {\n    // If receiver is a getter, then it is the object on which the search first started for the property|key -> Proxy\n    set(target, key, val, receiver) {\n      if (trackDeps) {\n        trackProxies.add(receiver);\n        if (trackMap.has(receiver)) {\n          trackMap.get(receiver).add(key);\n        } else {\n          trackMap.set(receiver, new Set([key]));\n        }\n      }\n      let returnSet = true;\n      let oldVal = Reflect.get(target, key, receiver);\n      if (oldVal === val) return returnSet;\n      // Reset Path - mostly GC\n      if (val === null) {\n        // Remove entry from reactitivyMap underlying Map\n        if (reactivityMap.has(receiver)) {\n          const key2NodeMap = reactivityMap.get(receiver);\n          key2NodeMap.delete(String(key));\n          if (key2NodeMap.size === 0) {\n            reactivityMap.delete(receiver);\n          }\n        }\n        // Inform the Observers about null change and unobserve\n        const observer = Reflect.get(target, handlers, receiver);\n        if (observer.has(key)) {\n          let set = observer.get(key);\n          for (const handler of set) {\n            handler(null, oldVal);\n          }\n          set.clear();\n          receiver.unobserve(key);\n        }\n        // If oldVal is a Proxy - clean it\n        if (isObject(oldVal) && isProxy(oldVal)) {\n          reactivityMap.delete(oldVal);\n          if (bindMap.has(oldVal)) {\n            bindMap.get(oldVal).forEach(removeElement);\n            bindMap.delete(oldVal);\n          }\n        } else {\n          if (bindMap.has(receiver)) {\n            bindMap.get(receiver).forEach(removeElement);\n            bindMap.delete(receiver);\n          }\n        }\n        // Remove item from array\n        /* c8 ignore next 4 */\n        if (!internReset && Array.isArray(receiver)) {\n          receiver.splice(Number(key), 1);\n          return returnSet;\n        }\n        return Reflect.deleteProperty(receiver, key);\n      }\n      // Set the value\n      if (isPromise(val)) {\n        const promise = val;\n        promise.then(value => {\n          // No Reflect in order to trigger the Getter\n          receiver[key] = value;\n        }).catch(e => {\n          console.error(e);\n          receiver[key] = null;\n        });\n        returnSet = Reflect.set(target, key, val, receiver);\n        return returnSet;\n      } else if (isNode(val)) {\n        returnSet = Reflect.set(target, key, val, receiver);\n      } else if (isObject(val) && !isProxy(val)) {\n        returnSet = Reflect.set(target, key, generateProxy(val), receiver);\n        // Recursively set properties to Proxys too\n        for (const [subKey, subVal] of Object.entries(val)) {\n          if (isObject(subVal) && !isProxy(subVal)) {\n            Reflect.set(val, subKey, generateProxy(subVal));\n          }\n        }\n      } else {\n        if (!reuseElements && Array.isArray(receiver) && receiver.includes(oldVal) && receiver.includes(val) && /* c8 ignore start */\n        bindMap.has(val)) {\n          const [elem] = bindMap.get(val);\n          if (lastSwapElem !== elem) {\n            const [oldElem] = bindMap.get(oldVal);\n            lastSwapElem = oldElem;\n            const prevElem = elem.previousSibling;\n            const prevOldElem = oldElem.previousSibling;\n            // Move it in the array too without triggering the proxy set\n            const index = receiver.findIndex(i => i === val);\n            receiver.splice(Number(key), 1, val);\n            receiver.splice(index, 1, oldVal);\n            prevElem.after(oldElem);\n            prevOldElem.after(elem);\n          }\n          return true;\n        } else {\n          /* c8 ignore end */\n          returnSet = Reflect.set(target, key, val, receiver);\n        }\n      }\n      const newVal = Reflect.get(target, key, receiver);\n      // Check if DOM needs to be updated\n      // oldVal can be Proxy value too\n      if (reactivityMap.has(oldVal)) {\n        checkReactivityMap(oldVal, key, newVal, oldVal);\n      } else if (reactivityMap.has(receiver)) {\n        checkReactivityMap(receiver, key, newVal, oldVal);\n      }\n      // current val (before setting) is a proxy - take over its keyToNodeMap\n      if (isObject(val) && isProxy(val)) {\n        if (reactivityMap.has(oldVal)) {\n          // Store old reactivityMap if it is a swap operation\n          reuseElements && tmpSwap.set(oldVal, reactivityMap.get(oldVal));\n          if (tmpSwap.has(val)) {\n            reactivityMap.set(oldVal, tmpSwap.get(val));\n            tmpSwap.delete(val);\n          } else {\n            reactivityMap.set(oldVal, reactivityMap.get(val));\n          }\n        }\n      }\n      // Inform the Observers\n      if (returnSet) {\n        Reflect.get(target, handlers, receiver).get(key)?.forEach(handler => handler(newVal, oldVal));\n      }\n      // If oldVal is a Proxy - clean it\n      !reuseElements && oldVal && cleanProxy(oldVal);\n      return returnSet;\n    },\n    // fix proxy bugs, e.g Map\n    get(target, prop, receiver) {\n      if (trackDeps) {\n        trackProxies.add(receiver);\n        if (trackMap.has(receiver)) {\n          trackMap.get(receiver).add(prop);\n        } else {\n          trackMap.set(receiver, new Set([prop]));\n        }\n      }\n      const value = Reflect.get(target, prop, receiver);\n      if (!isFunction(value)) {\n        return value;\n      }\n      if (!boundFunctions.has(value)) {\n        boundFunctions.set(value, value.bind(target));\n      }\n      return boundFunctions.get(value);\n    }\n  });\n  Reflect.defineProperty(proxy, \"isProxy\" /* Placeholder.isProxy */, {\n    value: true\n  });\n  Reflect.defineProperty(proxy, \"asyncUpdate\" /* Placeholder.asyncUpdate */, {\n    value: globalSchedule,\n    writable: true\n  });\n  Reflect.defineProperty(proxy, handlers, {\n    value: new Map()\n  });\n  Reflect.defineProperty(proxy, \"observe\" /* Placeholder.observe */, {\n    value(key, handler) {\n      const map = Reflect.get(proxy, handlers);\n      if (map.has(key)) {\n        map.get(key).add(handler);\n      } else {\n        map.set(key, new Set([handler]));\n      }\n    },\n    configurable: true\n  });\n  Reflect.defineProperty(proxy, \"getObservers\" /* Placeholder.getObservers */, {\n    value() {\n      return Reflect.get(proxy, handlers);\n    },\n    configurable: true\n  });\n  Reflect.defineProperty(proxy, \"unobserve\" /* Placeholder.unobserve */, {\n    value(key, handler) {\n      const map = Reflect.get(proxy, handlers);\n      if (key) {\n        if (map.has(key)) {\n          if (handler == null) {\n            map.delete(key);\n          } else {\n            const set = map.get(key);\n            if (set?.has(handler)) {\n              set.delete(handler);\n            }\n          }\n        }\n        /* c8 ignore next 3 */\n      } else {\n        map.clear();\n      }\n    },\n    configurable: true\n  });\n  if (!obj) Reflect.defineProperty(proxy, _boundFunctions, {\n    value: boundFunctions\n  });\n  return proxy;\n}\nfunction cleanProxy(proxy) {\n  if (isObject(proxy) && isProxy(proxy)) {\n    reactivityMap.delete(proxy);\n    /* c8 ignore next 4 */\n    if (bindMap.has(proxy)) {\n      bindMap.get(proxy).forEach(removeElement);\n      bindMap.delete(proxy);\n    }\n  }\n}\nfunction checkReactivityMap(obj, key, val, oldVal) {\n  const keyToNodeMap = reactivityMap.get(obj);\n  const nodeToChangeMap = keyToNodeMap.get(String(key));\n  if (nodeToChangeMap) {\n    /* c8 ignore next 5 */\n    if (Reflect.get(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */)) {\n      schedule(updateDOM, nodeToChangeMap, val, oldVal);\n    } else {\n      updateDOM(nodeToChangeMap, val, oldVal);\n    }\n  }\n  if (isObject(val)) {\n    for (const [subKey, subVal] of Object.entries(val)) {\n      const subOldVal = isObject(oldVal) && Reflect.get(oldVal, subKey) || oldVal;\n      const nodeToChangeMap = keyToNodeMap.get(subKey);\n      if (nodeToChangeMap) {\n        /* c8 ignore next 5 */\n        if (Reflect.get(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */)) {\n          schedule(updateDOM, nodeToChangeMap, subVal, subOldVal);\n        } else {\n          updateDOM(nodeToChangeMap, subVal, subOldVal);\n        }\n      }\n    }\n  }\n}\nfunction updateDOM(nodeToChangeMap, val, oldVal) {\n  nodeToChangeMap.forEach(entry => {\n    // Circular reference in order to keep Memory low\n    if (isNode(entry)) {\n      /* c8 ignore next 5 */\n      if (!ignoreIsConnected && !entry.isConnected) {\n        const tmpChange = nodeToChangeMap.get(entry);\n        nodeToChangeMap.delete(entry);\n        nodeToChangeMap.delete(tmpChange);\n      }\n      return; // Continue in forEach\n    }\n    // For each change of the node update either attribute or textContent\n    for (const change of entry) {\n      const node = nodeToChangeMap.get(entry);\n      const [start, end, key] = change;\n      let useStartEnd = false;\n      if (isNode(val)) {\n        replaceElement(val, node);\n        if (val !== node) {\n          nodeToChangeMap.delete(node);\n          if (!isDocumentFragment(val)) {\n            nodeToChangeMap.set(val, entry);\n            nodeToChangeMap.set(entry, val);\n          }\n        }\n      } else if (isTextNode(node)) {\n        useStartEnd = true;\n        let text = node.nodeValue;\n        node.nodeValue = text.substring(0, start) + String(val) + text.substring(end);\n      } else {\n        if (key === \"two-way\" /* Placeholder.twoWay */) {\n          if (node instanceof HTMLInputElement && node.type === \"radio\" /* Placeholder.radio */) {\n            node.checked = Array.isArray(val) ? val.includes(node.name) : String(val) === node.value;\n          } else if (node instanceof HTMLInputElement && node.type === \"checkbox\" /* Placeholder.checkbox */) {\n            node.checked = val;\n          } else if (node instanceof HTMLTextAreaElement || node instanceof HTMLSelectElement || node instanceof HTMLInputElement) {\n            node.value = String(val);\n          }\n        } else if (isFunction(val) || isEventObject(val)) {\n          const eventName = key.replace(onEventRegex, \"\");\n          node.removeEventListener(eventName, isFunction(oldVal) ? oldVal : oldVal.event);\n          addEventListener(node, eventName, val);\n        } else if (isObject(val)) {\n          for (const [subKey, subVal] of Object.entries(val)) {\n            if (isFunction(subVal) || isEventObject(subVal)) {\n              const eventName = subKey.replace(onEventRegex, \"\");\n              node.removeEventListener(eventName, isFunction(oldVal[subKey]) ? oldVal[subKey] : oldVal[subKey].event);\n              addEventListener(node, eventName, subVal);\n            } else {\n              setAttribute(node, subKey, subVal);\n            }\n          }\n        } else {\n          useStartEnd = true;\n          let attr = node.getAttribute(key);\n          if (attr) {\n            attr = attr.substring(0, start) + String(val) + attr.substring(end);\n            setAttribute(node, key, attr === String(val) ? val : attr);\n          } else {\n            setAttribute(node, key, val);\n          }\n        }\n      }\n      if (useStartEnd) {\n        // Update end\n        change[1] = start + String(val).length;\n        // Because we updated the end, we also have to update the start and end for every other reactive change in the node, for the same key\n        if (allNodeChanges.has(node)) {\n          let passedNode = false;\n          for (const nodeChange of allNodeChanges.get(node)) {\n            if (nodeChange === change) {\n              passedNode = true;\n              continue;\n            }\n            if (passedNode && (isTextNode(node) || key === nodeChange[2])) {\n              const difference = String(oldVal).length - String(val).length;\n              nodeChange[0] -= difference;\n              nodeChange[1] -= difference;\n            }\n          }\n        }\n      }\n    }\n  });\n}\nfunction view(root, data, renderFunction) {\n  viewElements = true;\n  const rootElem = $(root);\n  const elements = getValue(data).map(renderFunction);\n  rootElem.append(...elements);\n  for (const elem of elements) runLifecyle(elem, onRenderMap);\n  if (rootElem.hasChildNodes()) setReactivity(rootElem);\n  onCleanup(unset, rootElem, data);\n  viewElements = false;\n  observe(data, (newData, oldData) => {\n    /* c8 ignore start */\n    viewElements = true;\n    // Reset or re-use\n    if (!newData?.length || !reuseElements && newData?.length === oldData?.length) {\n      rootElem.textContent = \"\";\n    } else if (reuseElements) {\n      for (let i = 0; i < oldData?.length && newData?.length; i++) {\n        oldData[i].id = newData[i].id;\n        oldData[i].label = newData[i].label;\n        newData[i] = oldData[i];\n      }\n    }\n    // Add to existing\n    if (oldData?.length && newData?.length > oldData?.length && newData[0] === oldData[0]) {\n      const length = oldData.length;\n      const slicedData = newData.slice(length);\n      const newElements = slicedData.map((item, i) => renderFunction(item, i + length));\n      rootElem.append(...newElements);\n      for (const elem of newElements) runLifecyle(elem, onRenderMap);\n    }\n    // Add new\n    else if (oldData?.length === 0 || !reuseElements && newData?.length) {\n      if (!reuseElements && oldData?.length && rootElem.hasChildNodes()) {\n        rootElem.textContent = \"\";\n      }\n      const elements = newData.map(renderFunction);\n      rootElem.append(...elements);\n      for (const elem of elements) runLifecyle(elem, onRenderMap);\n    }\n    if (rootElem.hasChildNodes()) setReactivity(rootElem);\n    viewElements = false;\n    /* c8 ignore end */\n  });\n}\nconst hydro = generateProxy();\nconst $ = document.querySelector.bind(document);\nconst $$ = document.querySelectorAll.bind(document);\nconst internals = {\n  compare,\n  allNodeChanges,\n  hydroToReactive,\n  boolAttrList\n};\nexport { render, html, h, hydro, setGlobalSchedule, setReuseElements, setInsertDiffing, setShouldSetReactivity, setIgnoreIsConnected, reactive, unset, setAsyncUpdate, unobserve, observe, ternary, emit, watchEffect, internals, getValue, onRender, onCleanup, setReactivity, $, $$, view };","map":{"version":3,"names":["window","requestIdleCallback","cb","_","start","performance","now","setTimeout","didTimeout","timeRemaining","Math","max","range","document","createRange","selectNodeContents","createContextualFragment","lastChild","parser","bind","allNodeChanges","WeakMap","elemEventFunctions","reactivityMap","bindMap","tmpSwap","onRenderMap","onCleanupMap","fragmentToElements","hydroToReactive","_boundFunctions","Symbol","reactiveSymbol","keysSymbol","globalSchedule","reuseElements","insertBeforeDiffing","shouldSetReactivity","viewElements","ignoreIsConnected","reactivityRegex","HTML_FIND_INVALID","newLineRegex","propChainRegex","onEventRegex","boolAttrList","lastSwapElem","internReset","isObject","obj","isFunction","func","isTextNode","node","splitText","undefined","isNode","Node","isDocumentFragment","nodeType","isEventObject","isProxy","hydroObject","Reflect","get","isPromise","then","randomText","randomChars","result","i","charAt","floor","random","length","setGlobalSchedule","willSchedule","setHydroRecursive","hydro","setReuseElements","willReuse","setInsertDiffing","willInsert","setShouldSetReactivity","willSet","setIgnoreIsConnected","ignore","set","value","Object","values","setAttribute","key","val","isBoolAttr","includes","removeAttribute","has","addEventListener","eventName","event","options","html","htmlArray","variables","eventFunctions","insertNodes","resolvedVariables","variable","template","push","String","funcName","Array","isArray","index","item","join","entries","DOMString","raw","trim","replace","DOM","fillDOM","childNodes","firstChild","createTextNode","elem","root","createNodeIterator","NodeFilter","SHOW_ELEMENT","acceptNode","element","localName","endsWith","FILTER_ACCEPT","FILTER_REJECT","nextNode","tag","replacement","createElement","append","getAttributeNames","getAttribute","replaceWith","querySelectorAll","shift","setReactivity","h","name","props","children","hasOwnProperty","is","createDocumentFragment","some","map","getChildren","flat","child","setReactivitySingle","elems","startsWith","childNode","nodeValue","nextSibling","attr_OR_text","match","hydroMatch","hydroPath","properties","split","filter","Boolean","resolvedValue","resolvedObj","resolveObject","lastProp","end","after","setTraces","textContent","JSON","stringify","proxy","HTMLSelectElement","changeAttrVal","HTMLInputElement","type","checked","HTMLTextAreaElement","toggleAttribute","subKey","subVal","isChecked","changeHandler","onCleanup","removeEventListener","target","hydroKey","change","changeArr","keyToNodeMap","nodeToChangeMap","Map","propertyArray","prev","prop","compareEvents","where","onlyTextChildren","elemFunctions","whereFunctions","compare","isEqualNode","render","shouldSchedule","schedule","unmount","getValue","elemChildren","from","body","resolveStringToElement","$","noop","replaceElement","treeDiff","runLifecyle","subElem","executeLifecycle","lifecyleMap","fn","delete","calledOnRender","calledOnCleanup","elements","filterTag2Elements","tag2Elements","list","contains","isSameNode","splice","elemElements","unshift","whereElements","documentElement","before","wElem","sameElements","whereElem","newElems","oldElems","e","remove","clear","fragmentChildren","fragmentElements","fragWhere","forEach","removeElement","isConnected","args","scheduler","postTask","priority","reactive","initial","setter","chainKeysProxy","chainKeys","keys","description","returnVal","sameObject","Proxy","_receiver","toPrimitive","getReactiveKeys","reactiveHydro","unset","oneKey","setAsyncUpdate","asyncUpdate","observe","unobserve","ternary","condition","trueVal","falseVal","checkCondition","cond","ternaryValue","newVal","emit","data","who","bubbles","dispatchEvent","CustomEvent","detail","trackDeps","trackProxies","Set","trackMap","unobserveMap","watchEffect","reRun","entry","onRender","generateProxy","handlers","boundFunctions","receiver","add","returnSet","oldVal","key2NodeMap","size","observer","handler","Number","deleteProperty","promise","catch","console","error","oldElem","prevElem","previousSibling","prevOldElem","findIndex","checkReactivityMap","cleanProxy","defineProperty","writable","configurable","updateDOM","subOldVal","tmpChange","useStartEnd","text","substring","attr","passedNode","nodeChange","difference","view","renderFunction","rootElem","hasChildNodes","newData","oldData","id","label","slicedData","slice","newElements","querySelector","$$","internals"],"sources":["C:/Users/DELL/OneDrive/Desktop/REACTJS/myshop/node_modules/hydro-js/dist/library.js"],"sourcesContent":["// Safari Polyfills\nwindow.requestIdleCallback =\n    /* c8 ignore next 4 */\n    window.requestIdleCallback ||\n        ((cb, _, start = performance.now()) => setTimeout(cb, 0, {\n            didTimeout: false,\n            timeRemaining: () => Math.max(0, 5 - (performance.now() - start)),\n        }));\n// Safari Polyfills END\nconst range = document.createRange();\nrange.selectNodeContents(range.createContextualFragment(`<${\"template\" /* Placeholder.template */}>`).lastChild);\nconst parser = range.createContextualFragment.bind(range);\nconst allNodeChanges = new WeakMap(); // Maps a Node against an array of changes. An array is necessary because a node can have multiple variables for one text / attribute.\nconst elemEventFunctions = new WeakMap(); // Stores event functions in order to compare Elements against each other.\nconst reactivityMap = new WeakMap(); // Maps Proxy Objects to another Map(proxy-key, node).\nconst bindMap = new WeakMap(); // Bind an Element to data. If the data is being unset, the DOM Element disappears too.\nconst tmpSwap = new WeakMap(); // Take over keyToNodeMap if the new value is a hydro Proxy. Save old reactivityMap entry here, in case for a swap operation.\nconst onRenderMap = new WeakMap(); // Lifecycle Hook that is being called after rendering\nconst onCleanupMap = new WeakMap(); // Lifecycle Hook that is being called when unmount function is being called\nconst fragmentToElements = new WeakMap(); // Used to retreive Elements from DocumentFragment after it has been rendered â€“ for diffing\nconst hydroToReactive = new WeakMap(); // Used for internal mapping from hydroKeys to the the Proxy created by the reactive function\nconst _boundFunctions = Symbol(\"boundFunctions\"); // Cache for bound functions in Proxy, so that we create the bound version of each function only once\nconst reactiveSymbol = Symbol(\"reactive\");\nconst keysSymbol = Symbol(\"keys\");\nlet globalSchedule = true; // Decides whether to schedule rendering and updating (async)\nlet reuseElements = true; // Reuses Elements when rendering\nlet insertBeforeDiffing = false; // Makes sense in Chrome only\nlet shouldSetReactivity = true;\nlet viewElements = false;\nlet ignoreIsConnected = false;\nconst reactivityRegex = /\\{\\{([^]*?)\\}\\}/;\nconst HTML_FIND_INVALID = /<(\\/?)(html|head|body)(>|\\s.*?>)/g;\nconst newLineRegex = /\\n/g;\nconst propChainRegex = /[\\.\\[\\]]/;\nconst onEventRegex = /^on/;\n// https://html.spec.whatwg.org/#attributes-3\n// if value for bool attr is falsy, then remove attr\n// INFO: draggable and spellcheck are actually using booleans as string! Also, hidden is not really a bool attr, but is making use of the empty string too. Might consider to add 'translate' (yes and no as string)\nconst boolAttrList = [\n    \"allowfullscreen\",\n    \"async\",\n    \"autofocus\",\n    \"autoplay\",\n    \"checked\",\n    \"controls\",\n    \"draggable\",\n    \"default\",\n    \"defer\",\n    \"disabled\",\n    \"formnovalidate\",\n    \"hidden\",\n    \"inert\",\n    \"ismap\",\n    \"itemscope\",\n    \"loop\",\n    \"multiple\",\n    \"muted\",\n    \"nomodule\",\n    \"novalidate\",\n    \"open\",\n    \"playsinline\",\n    \"readonly\",\n    \"required\",\n    \"reversed\",\n    \"selected\",\n    \"spellcheck\",\n];\nlet lastSwapElem = null;\nlet internReset = false;\nfunction isObject(obj) {\n    return obj != null && typeof obj === \"object\";\n}\nfunction isFunction(func) {\n    return typeof func === \"function\" /* Placeholder.function */;\n}\nfunction isTextNode(node) {\n    return node.splitText !== undefined;\n}\nfunction isNode(node) {\n    return node instanceof Node;\n}\nfunction isDocumentFragment(node) {\n    return node.nodeType === 11;\n}\nfunction isEventObject(obj) {\n    return (isObject(obj) && \"event\" /* Placeholder.event */ in obj && \"options\" /* Placeholder.options */ in obj);\n}\nfunction isProxy(hydroObject) {\n    return Reflect.get(hydroObject, \"isProxy\" /* Placeholder.isProxy */);\n}\nfunction isPromise(obj) {\n    return isObject(obj) && typeof obj.then === \"function\";\n}\nfunction randomText() {\n    const randomChars = \"abcdefghijklmnopqrstuvwxyz0123456789\";\n    let result = \"\";\n    for (var i = 0; i < 6; i++) {\n        result += randomChars.charAt(Math.floor(Math.random() * randomChars.length));\n    }\n    return result;\n    // return Math.random().toString(32).slice(2);\n}\nfunction setGlobalSchedule(willSchedule) {\n    globalSchedule = willSchedule;\n    setHydroRecursive(hydro);\n}\nfunction setReuseElements(willReuse) {\n    reuseElements = willReuse;\n}\nfunction setInsertDiffing(willInsert) {\n    insertBeforeDiffing = willInsert;\n}\nfunction setShouldSetReactivity(willSet) {\n    shouldSetReactivity = willSet;\n}\nfunction setIgnoreIsConnected(ignore) {\n    ignoreIsConnected = ignore;\n}\nfunction setHydroRecursive(obj) {\n    Reflect.set(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */, globalSchedule);\n    for (const value of Object.values(obj)) {\n        if (isObject(value) && isProxy(value)) {\n            setHydroRecursive(value);\n        }\n    }\n}\nfunction setAttribute(node, key, val) {\n    const isBoolAttr = boolAttrList.includes(key);\n    if (isBoolAttr && !val) {\n        node.removeAttribute(key);\n        return false;\n    }\n    node.setAttribute(key, isFunction(val) && Reflect.has(val, reactiveSymbol)\n        ? val\n        : isBoolAttr\n            ? \"\"\n            : val);\n    return true;\n}\nfunction addEventListener(node, eventName, obj) {\n    node.addEventListener(eventName, isFunction(obj) ? obj : obj.event, isFunction(obj) ? {} : obj.options);\n}\nfunction html(htmlArray, ...variables) {\n    const eventFunctions = {}; // Temporarily store a mapping for string -> function, because eventListener have to be registered after the Element's creation\n    let insertNodes = []; // Nodes, that will be added after the parsing\n    const resolvedVariables = [];\n    for (const variable of variables) {\n        const template = `<${\"template\" /* Placeholder.template */} id=\"lbInsertNodes\"></${\"template\" /* Placeholder.template */}>`;\n        if (isNode(variable)) {\n            insertNodes.push(variable);\n            resolvedVariables.push(template);\n        }\n        else if ([\"number\", \"string\" /* Placeholder.string */, \"symbol\", \"boolean\", \"bigint\"].includes(typeof variable) ||\n            Reflect.has(variable, reactiveSymbol)) {\n            resolvedVariables.push(String(variable));\n        }\n        else if (isFunction(variable) || isEventObject(variable)) {\n            const funcName = randomText();\n            Reflect.set(eventFunctions, funcName, variable);\n            resolvedVariables.push(funcName);\n        }\n        else if (Array.isArray(variable)) {\n            for (let index = 0; index < variable.length; index++) {\n                const item = variable[index];\n                if (isNode(item)) {\n                    insertNodes.push(item);\n                    variable[index] = template;\n                }\n            }\n            resolvedVariables.push(variable.join(\"\"));\n        }\n        else if (isObject(variable)) {\n            let result = \"\";\n            for (const [key, value] of Object.entries(variable)) {\n                if (isFunction(value) || isEventObject(value)) {\n                    const funcName = randomText();\n                    Reflect.set(eventFunctions, funcName, value);\n                    result += `${key}=\"${funcName}\"`;\n                }\n                else {\n                    result += `${key}=\"${value}\"`;\n                }\n            }\n            resolvedVariables.push(result);\n        }\n    }\n    // Find elements <html|head|body>, as they cannot be created by the parser. Replace them by fake Custom Elements and replace them afterwards.\n    let DOMString = String.raw(htmlArray, ...resolvedVariables).trim();\n    DOMString = DOMString.replace(HTML_FIND_INVALID, `<$1$2${\"-dummy\" /* Placeholder.dummy */}$3`);\n    const DOM = parser(DOMString);\n    // Delay Element iteration and manipulation after the elements have been added to the DOM.\n    if (!viewElements) {\n        fillDOM(DOM, insertNodes, eventFunctions);\n    }\n    // Return DocumentFragment\n    if (DOM.childNodes.length > 1)\n        return DOM;\n    // Return empty Text Node\n    if (!DOM.firstChild)\n        return document.createTextNode(\"\");\n    // Return Element | Text\n    return DOM.firstChild;\n}\nfunction fillDOM(elem, insertNodes, eventFunctions) {\n    const root = document.createNodeIterator(elem, NodeFilter.SHOW_ELEMENT, {\n        acceptNode(element) {\n            return element.localName.endsWith(\"-dummy\" /* Placeholder.dummy */)\n                ? NodeFilter.FILTER_ACCEPT\n                : NodeFilter.FILTER_REJECT;\n        },\n    });\n    let nextNode;\n    while ((nextNode = root.nextNode())) {\n        const tag = nextNode.localName.replace(\"-dummy\" /* Placeholder.dummy */, \"\");\n        const replacement = document.createElement(tag);\n        replacement.append(...nextNode.childNodes);\n        /* c8 ignore next 3 */\n        for (const key of nextNode.getAttributeNames()) {\n            replacement.setAttribute(key, nextNode.getAttribute(key));\n        }\n        nextNode.replaceWith(replacement);\n    }\n    // Insert HTML Elements, which were stored in insertNodes\n    if (!isTextNode(elem)) {\n        for (const template of elem.querySelectorAll(\"template[id^=lbInsertNodes]\"))\n            template.replaceWith(insertNodes.shift());\n    }\n    if (shouldSetReactivity)\n        setReactivity(elem, eventFunctions);\n}\nfunction h(name, props, ...children) {\n    if (isFunction(name))\n        return name({ ...props, children });\n    const elem = typeof name === \"string\" /* Placeholder.string */\n        ? document.createElement(name, props?.hasOwnProperty(\"is\") ? { is: props[\"is\"] } : undefined)\n        : document.createDocumentFragment();\n    for (let i in props) {\n        i in elem && !boolAttrList.includes(i)\n            ? //@ts-ignore\n                (elem[i] = props[i])\n            : setAttribute(elem, i, props[i]);\n    }\n    if (isDocumentFragment(elem)) {\n        children = name.children;\n    }\n    elem.append(...(children.some((i) => Array.isArray(i))\n        ? children.map(getChildren).flat()\n        : children));\n    if (!viewElements) {\n        setReactivity(elem);\n    }\n    return elem;\n}\nfunction getChildren(child) {\n    return isObject(child) && !isNode(child)\n        ? Object.values(child)\n        : child;\n}\n/* c8 ignore end */\nfunction setReactivity(DOM, eventFunctions) {\n    if (isTextNode(DOM)) {\n        setReactivitySingle(DOM);\n        return;\n    }\n    const elems = document.createNodeIterator(DOM, NodeFilter.SHOW_ELEMENT);\n    let elem;\n    while ((elem = elems.nextNode())) {\n        for (const key of elem.getAttributeNames()) {\n            // Set functions\n            const val = elem.getAttribute(key);\n            if (eventFunctions && key.startsWith(\"on\")) {\n                const eventName = key.replace(onEventRegex, \"\");\n                const event = eventFunctions[val];\n                if (!event) {\n                    setReactivitySingle(elem, key, val);\n                    continue;\n                }\n                elem.removeAttribute(key);\n                if (isEventObject(event)) {\n                    elem.addEventListener(eventName, event.event, event.options);\n                    if (elemEventFunctions.has(elem)) {\n                        elemEventFunctions.get(elem).push(event.event);\n                    }\n                    else {\n                        elemEventFunctions.set(elem, [event.event]);\n                    }\n                }\n                else {\n                    elem.addEventListener(eventName, event);\n                    if (elemEventFunctions.has(elem)) {\n                        elemEventFunctions.get(elem).push(event);\n                    }\n                    else {\n                        elemEventFunctions.set(elem, [event]);\n                    }\n                }\n            }\n            else {\n                setReactivitySingle(elem, key, val);\n            }\n        }\n        let childNode = elem.firstChild;\n        while (childNode) {\n            if (isTextNode(childNode) && childNode.nodeValue?.includes(\"{{\")) {\n                setReactivitySingle(childNode);\n            }\n            childNode = childNode.nextSibling;\n        }\n    }\n}\nfunction setReactivitySingle(node, key, val) {\n    let attr_OR_text, match;\n    if (!key) {\n        attr_OR_text = node.nodeValue; // nodeValue is (always) defined on Text Nodes\n    }\n    else {\n        attr_OR_text = val;\n        if (attr_OR_text === \"\") {\n            // e.g. checked attribute or two-way attribute\n            attr_OR_text = key;\n            if (attr_OR_text.startsWith(\"{{\")) {\n                node.removeAttribute(attr_OR_text);\n            }\n        }\n    }\n    while ((match = attr_OR_text.match(reactivityRegex))) {\n        // attr_OR_text will be altered in every iteration\n        const [hydroMatch, hydroPath] = match;\n        const properties = hydroPath\n            .trim()\n            .replace(newLineRegex, \"\")\n            .split(propChainRegex)\n            .filter(Boolean);\n        const [resolvedValue, resolvedObj] = resolveObject(properties);\n        let lastProp = properties[properties.length - 1];\n        const start = match.index;\n        let end = start + String(resolvedValue).length;\n        if (isNode(resolvedValue)) {\n            node.nodeValue = attr_OR_text.replace(hydroMatch, \"\");\n            node.after(resolvedValue);\n            setTraces(start, end, resolvedValue, lastProp, resolvedObj, key);\n            return;\n        }\n        // Set Text or set Attribute\n        if (isTextNode(node)) {\n            const textContent = isObject(resolvedValue)\n                ? JSON.stringify(resolvedValue)\n                : resolvedValue ?? \"\";\n            attr_OR_text = attr_OR_text.replace(hydroMatch, textContent);\n            if (attr_OR_text != null) {\n                node.nodeValue = attr_OR_text;\n            }\n        }\n        else {\n            if (key === \"bind\") {\n                attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n                node.removeAttribute(key);\n                const proxy = isObject(resolvedValue) && isProxy(resolvedValue)\n                    ? resolvedValue\n                    : resolvedObj;\n                if (bindMap.has(proxy)) {\n                    bindMap.get(proxy).push(node);\n                }\n                else {\n                    bindMap.set(proxy, [node]);\n                }\n                continue;\n            }\n            else if (key === \"two-way\" /* Placeholder.twoWay */) {\n                if (node instanceof HTMLSelectElement) {\n                    node.value = resolvedValue;\n                    changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp);\n                }\n                else if (node instanceof HTMLInputElement &&\n                    node.type === \"radio\" /* Placeholder.radio */) {\n                    node.checked = node.value === resolvedValue;\n                    changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp);\n                }\n                else if (node instanceof HTMLInputElement &&\n                    node.type === \"checkbox\" /* Placeholder.checkbox */) {\n                    node.checked = resolvedValue;\n                    changeAttrVal(\"change\" /* Placeholder.change */, node, resolvedObj, lastProp, true);\n                }\n                else if (node instanceof HTMLTextAreaElement ||\n                    node instanceof HTMLInputElement) {\n                    node.value = resolvedValue;\n                    changeAttrVal(\"input\", node, resolvedObj, lastProp);\n                }\n                attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n                node.toggleAttribute(\"two-way\" /* Placeholder.twoWay */);\n            }\n            else if (isFunction(resolvedValue) || isEventObject(resolvedValue)) {\n                attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n                node.removeAttribute(key);\n                addEventListener(node, key.replace(onEventRegex, \"\"), resolvedValue);\n            }\n            else if (isObject(resolvedValue)) {\n                // Case: setting attrs on Element - <p ${props}>\n                for (const [subKey, subVal] of Object.entries(resolvedValue)) {\n                    attr_OR_text = attr_OR_text.replace(hydroMatch, \"\");\n                    if (isFunction(subVal) || isEventObject(subVal)) {\n                        addEventListener(node, subKey.replace(onEventRegex, \"\"), subVal);\n                    }\n                    else {\n                        lastProp = subKey;\n                        if (setAttribute(node, subKey, subVal)) {\n                            end = start + String(subVal).length;\n                        }\n                        else {\n                            end = start;\n                        }\n                    }\n                    setTraces(start, end, node, lastProp, resolvedValue, subKey);\n                }\n                continue; // As we set all Mappings via subKeys\n            }\n            else {\n                attr_OR_text = attr_OR_text.replace(hydroMatch, resolvedValue);\n                if (!setAttribute(node, key, attr_OR_text === String(resolvedValue)\n                    ? resolvedValue\n                    : attr_OR_text)) {\n                    attr_OR_text = attr_OR_text.replace(resolvedValue, \"\");\n                }\n            }\n        }\n        setTraces(start, end, node, lastProp, resolvedObj, key);\n    }\n}\n// Same behavior as v-model in https://v3.vuejs.org/guide/forms.html#basic-usage\nfunction changeAttrVal(eventName, node, resolvedObj, lastProp, isChecked = false) {\n    node.addEventListener(eventName, changeHandler);\n    onCleanup(() => node.removeEventListener(eventName, changeHandler), node);\n    function changeHandler({ target }) {\n        Reflect.set(resolvedObj, lastProp, isChecked\n            ? target.checked\n            : target.value);\n    }\n}\nfunction setTraces(start, end, node, hydroKey, resolvedObj, key) {\n    // Set WeakMaps, that will be used to track a change for a Node but also to check if a Node has any other changes.\n    const change = [start, end, key, resolvedObj];\n    const changeArr = [change];\n    if (allNodeChanges.has(node)) {\n        allNodeChanges.get(node).push(change);\n    }\n    else {\n        allNodeChanges.set(node, [change]); // Use own version. Otherwise changes, will lead to incorrect changes in the DOM.\n    }\n    if (reactivityMap.has(resolvedObj)) {\n        const keyToNodeMap = reactivityMap.get(resolvedObj);\n        const nodeToChangeMap = keyToNodeMap.get(hydroKey);\n        if (nodeToChangeMap) {\n            if (nodeToChangeMap.has(node)) {\n                nodeToChangeMap.get(node).push(change);\n            }\n            else {\n                nodeToChangeMap.set(changeArr, node);\n                nodeToChangeMap.set(node, changeArr);\n            }\n        }\n        else {\n            keyToNodeMap.set(hydroKey, \n            //@ts-ignore\n            new Map([\n                [changeArr, node],\n                [node, changeArr],\n            ]));\n        }\n    }\n    else {\n        reactivityMap.set(resolvedObj, new Map([\n            [\n                hydroKey,\n                //@ts-ignore\n                new Map([\n                    [changeArr, node],\n                    [node, changeArr],\n                ]),\n            ],\n        ]));\n    }\n}\n// Helper function to return a value and hydro obj from a chain of properties\nfunction resolveObject(propertyArray) {\n    let value, prev;\n    value = prev = hydro;\n    for (const prop of propertyArray) {\n        prev = value;\n        value = Reflect.get(prev, prop);\n    }\n    return [value, prev];\n}\nfunction compareEvents(elem, where, onlyTextChildren) {\n    const elemFunctions = [];\n    const whereFunctions = [];\n    if (isTextNode(elem)) {\n        if (onRenderMap.has(elem)) {\n            elemFunctions.push(onRenderMap.get(elem));\n        }\n        if (onCleanupMap.has(elem)) {\n            elemFunctions.push(onCleanupMap.get(elem));\n        }\n        if (onRenderMap.has(where)) {\n            whereFunctions.push(onRenderMap.get(where));\n        }\n        if (onCleanupMap.has(where)) {\n            whereFunctions.push(onCleanupMap.get(where));\n        }\n        if (elemFunctions.length !== whereFunctions.length)\n            return false;\n        if (String(elemFunctions) !== String(whereFunctions))\n            return false;\n        return true;\n    }\n    if (elemEventFunctions.has(elem)) {\n        elemFunctions.push(...elemEventFunctions.get(elem));\n    }\n    if (elemEventFunctions.has(where)) {\n        whereFunctions.push(...elemEventFunctions.get(where));\n    }\n    if (onRenderMap.has(elem)) {\n        elemFunctions.push(onRenderMap.get(elem));\n    }\n    if (onCleanupMap.has(elem)) {\n        elemFunctions.push(onCleanupMap.get(elem));\n    }\n    if (onRenderMap.has(where)) {\n        whereFunctions.push(onRenderMap.get(where));\n    }\n    if (onCleanupMap.has(where)) {\n        whereFunctions.push(onCleanupMap.get(where));\n    }\n    if (elemFunctions.length !== whereFunctions.length)\n        return false;\n    if (String(elemFunctions) !== String(whereFunctions))\n        return false;\n    for (let i = 0; i < elem.childNodes.length; i++) {\n        if (onlyTextChildren) {\n            if (isTextNode(elem.childNodes[i])) {\n                if (!compareEvents(elem.childNodes[i], where.childNodes[i], onlyTextChildren)) {\n                    return false;\n                }\n            }\n        }\n        else {\n            if (!compareEvents(elem.childNodes[i], where.childNodes[i])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction compare(elem, where, onlyTextChildren) {\n    if (isDocumentFragment(elem) || isDocumentFragment(where))\n        return false;\n    return (elem.isEqualNode(where) && compareEvents(elem, where, onlyTextChildren));\n}\nfunction render(elem, where = \"\", shouldSchedule = globalSchedule) {\n    /* c8 ignore next 4 */\n    if (shouldSchedule) {\n        schedule(render, elem, where, false);\n        return unmount(elem);\n    }\n    // Get elem value if elem is reactiveObject\n    if (Reflect.has(elem, reactiveSymbol)) {\n        elem = getValue(elem);\n    }\n    // Store elements of documentFragment for later unmount\n    let elemChildren = [];\n    if (isDocumentFragment(elem)) {\n        elemChildren = Array.from(elem.childNodes);\n        fragmentToElements.set(elem, elemChildren); // For diffing later\n    }\n    if (!where) {\n        document.body.append(elem);\n    }\n    else {\n        if (typeof where === \"string\" /* Placeholder.string */) {\n            const resolveStringToElement = $(where);\n            if (resolveStringToElement) {\n                where = resolveStringToElement;\n            }\n            else {\n                return noop;\n            }\n        }\n        if (!reuseElements) {\n            replaceElement(elem, where);\n        }\n        else {\n            if (isTextNode(elem)) {\n                replaceElement(elem, where);\n            }\n            else if (!compare(elem, where)) {\n                treeDiff(elem, where);\n            }\n        }\n    }\n    runLifecyle(elem, onRenderMap);\n    for (const subElem of elemChildren) {\n        runLifecyle(subElem, onRenderMap);\n    }\n    return unmount(isDocumentFragment(elem) ? elemChildren : elem);\n}\nfunction noop() { }\nfunction executeLifecycle(node, lifecyleMap) {\n    if (lifecyleMap.has(node)) {\n        const fn = lifecyleMap.get(node);\n        if (globalSchedule) {\n            schedule(fn);\n        }\n        else {\n            fn();\n        }\n        lifecyleMap.delete(node);\n    }\n}\nfunction runLifecyle(node, lifecyleMap) {\n    if ((lifecyleMap === onRenderMap && !calledOnRender) ||\n        (lifecyleMap === onCleanupMap && !calledOnCleanup))\n        return;\n    executeLifecycle(node, lifecyleMap);\n    const elements = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n    let subElem;\n    while ((subElem = elements.nextNode())) {\n        executeLifecycle(subElem, lifecyleMap);\n        let childNode = subElem.firstChild;\n        while (childNode) {\n            if (isTextNode(childNode)) {\n                executeLifecycle(childNode, lifecyleMap);\n            }\n            childNode = childNode.nextSibling;\n        }\n    }\n}\nfunction filterTag2Elements(tag2Elements, root) {\n    for (const [localName, list] of tag2Elements.entries()) {\n        for (let i = 0; i < list.length; i++) {\n            const elem = list[i];\n            if (root.contains(elem) || root.isSameNode(elem)) {\n                list.splice(i, 1);\n                i--;\n            }\n            if (list.length === 0) {\n                tag2Elements.delete(localName);\n            }\n        }\n    }\n}\nfunction treeDiff(elem, where) {\n    let elemElements = [...elem.querySelectorAll(\"*\")];\n    if (!isDocumentFragment(elem))\n        elemElements.unshift(elem);\n    let whereElements = [];\n    if (!isTextNode(where)) {\n        whereElements = [...where.querySelectorAll(\"*\")];\n        if (!isDocumentFragment(where))\n            whereElements.unshift(where);\n    }\n    let template;\n    if (insertBeforeDiffing) {\n        template = document.createElement(\"template\" /* Placeholder.template */);\n        /* c8 ignore next 3 */\n        if (where === document.documentElement) {\n            where.append(template);\n        }\n        else {\n            if (isDocumentFragment(where)) {\n                fragmentToElements.get(where)[0].before(template);\n            }\n            else {\n                where.before(template);\n            }\n        }\n        template.append(elem);\n    }\n    // Create Mapping for easier diffing, eg: \"div\" -> [...Element]\n    const tag2Elements = new Map();\n    for (const wElem of whereElements) {\n        /* c8 ignore next 2 */\n        if (insertBeforeDiffing && wElem === template)\n            return;\n        if (tag2Elements.has(wElem.localName)) {\n            tag2Elements.get(wElem.localName).push(wElem);\n        }\n        else {\n            tag2Elements.set(wElem.localName, [wElem]);\n        }\n    }\n    // Re-use any where Element if possible, then remove elem Element\n    for (const subElem of elemElements) {\n        const sameElements = tag2Elements.get(subElem.localName);\n        if (sameElements) {\n            for (const whereElem of sameElements) {\n                if (compare(subElem, whereElem, true)) {\n                    subElem.replaceWith(whereElem);\n                    runLifecyle(subElem, onCleanupMap);\n                    filterTag2Elements(tag2Elements, whereElem);\n                    break;\n                }\n            }\n        }\n    }\n    if (insertBeforeDiffing) {\n        const newElems = isDocumentFragment(elem)\n            ? Array.from(template.childNodes)\n            : [elem];\n        if (isDocumentFragment(where)) {\n            const oldElems = fragmentToElements.get(where);\n            for (const e of newElems)\n                oldElems[0].before(e);\n            for (const e of oldElems)\n                e.remove();\n        }\n        else {\n            where.replaceWith(...newElems);\n        }\n        template.remove();\n        runLifecyle(where, onCleanupMap);\n    }\n    else {\n        replaceElement(elem, where);\n    }\n    tag2Elements.clear();\n}\nfunction replaceElement(elem, where) {\n    if (isDocumentFragment(where)) {\n        const fragmentChildren = fragmentToElements.get(where);\n        if (isDocumentFragment(elem)) {\n            const fragmentElements = Array.from(elem.childNodes);\n            for (let index = 0; index < fragmentChildren.length; index++) {\n                const fragWhere = fragmentChildren[index];\n                if (index < fragmentElements.length) {\n                    render(fragmentElements[index], fragWhere);\n                }\n                else {\n                    fragWhere.remove();\n                }\n            }\n        }\n        else {\n            for (let index = 0; index < fragmentChildren.length; index++) {\n                const fragWhere = fragmentChildren[index];\n                if (index === 0) {\n                    render(elem, fragWhere);\n                }\n                else {\n                    fragWhere.remove();\n                }\n            }\n        }\n    }\n    else {\n        where.replaceWith(elem);\n    }\n    runLifecyle(where, onCleanupMap);\n}\nfunction unmount(elem) {\n    if (Array.isArray(elem)) {\n        return () => elem.forEach(removeElement);\n    }\n    else {\n        return () => removeElement(elem);\n    }\n}\nfunction removeElement(elem) {\n    if (!ignoreIsConnected && elem.isConnected) {\n        elem.remove();\n        runLifecyle(elem, onCleanupMap);\n    }\n}\n/* c8 ignore next 13 */\nasync function schedule(fn, ...args) {\n    if (\"scheduler\" in window) {\n        // @ts-ignore\n        scheduler.postTask(fn.bind(fn, ...args), { priority: \"background\" });\n    }\n    else {\n        window.requestIdleCallback(() => fn(...args));\n    }\n}\nfunction reactive(initial) {\n    let key;\n    do\n        key = randomText();\n    while (Reflect.has(hydro, key));\n    Reflect.set(hydro, key, initial);\n    Reflect.set(setter, reactiveSymbol, true);\n    const chainKeysProxy = chainKeys(setter, [key]);\n    if (isObject(initial)) {\n        hydroToReactive.set(Reflect.get(hydro, key), chainKeysProxy);\n    }\n    return chainKeysProxy;\n    function setter(val) {\n        const keys = // @ts-ignore\n         (this && Reflect.has(this, reactiveSymbol) ? this : chainKeysProxy)[keysSymbol.description];\n        const [resolvedValue, resolvedObj] = resolveObject(keys);\n        const lastProp = keys[keys.length - 1];\n        if (isFunction(val)) {\n            const returnVal = val(resolvedValue);\n            const sameObject = resolvedValue === returnVal;\n            if (sameObject)\n                return;\n            Reflect.set(resolvedObj, lastProp, returnVal ?? resolvedValue);\n        }\n        else {\n            Reflect.set(resolvedObj, lastProp, val);\n        }\n    }\n}\nfunction chainKeys(initial, keys) {\n    return new Proxy(initial, {\n        get(target, subKey, _receiver) {\n            if (subKey === reactiveSymbol.description)\n                return true;\n            if (subKey === keysSymbol.description) {\n                return keys;\n            }\n            if (subKey === Symbol.toPrimitive) {\n                return () => `{{${keys.join(\".\")}}}`;\n            }\n            return chainKeys(target, [...keys, subKey]);\n        },\n    });\n}\nfunction getReactiveKeys(reactiveHydro) {\n    const keys = reactiveHydro[keysSymbol.description];\n    const lastProp = keys[keys.length - 1];\n    return [lastProp, keys.length === 1];\n}\nfunction unset(reactiveHydro) {\n    const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n    if (oneKey) {\n        Reflect.set(hydro, lastProp, null);\n        if (hydroToReactive.has(hydro[lastProp])) {\n            hydroToReactive.delete(hydro[lastProp]);\n        }\n    }\n    else {\n        const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n        Reflect.set(resolvedObj, lastProp, null);\n    }\n}\nfunction setAsyncUpdate(reactiveHydro, asyncUpdate) {\n    const [_, oneKey] = getReactiveKeys(reactiveHydro);\n    if (oneKey) {\n        hydro.asyncUpdate = asyncUpdate;\n    }\n    else {\n        const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n        resolvedObj.asyncUpdate = asyncUpdate;\n    }\n}\nfunction observe(reactiveHydro, fn) {\n    const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n    if (oneKey) {\n        hydro.observe(lastProp, fn);\n    }\n    else {\n        const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n        resolvedObj.observe(lastProp, fn);\n    }\n}\nfunction unobserve(reactiveHydro) {\n    const [lastProp, oneKey] = getReactiveKeys(reactiveHydro);\n    if (oneKey) {\n        hydro.unobserve(lastProp);\n    }\n    else {\n        const [_, resolvedObj] = resolveObject(reactiveHydro[keysSymbol.description]);\n        resolvedObj.unobserve(lastProp);\n    }\n}\nfunction ternary(condition, trueVal, falseVal, reactiveHydro = condition) {\n    const checkCondition = (cond) => (!Reflect.has(condition, reactiveSymbol) && isFunction(condition)\n        ? condition(cond)\n        : isPromise(cond)\n            ? false\n            : cond)\n        ? isFunction(trueVal)\n            ? trueVal()\n            : trueVal\n        : isFunction(falseVal)\n            ? falseVal()\n            : falseVal;\n    const ternaryValue = reactive(checkCondition(getValue(reactiveHydro)));\n    observe(reactiveHydro, (newVal) => {\n        newVal === null\n            ? unset(ternaryValue)\n            : ternaryValue(checkCondition(newVal));\n    });\n    return ternaryValue;\n}\nfunction emit(eventName, data, who, options = { bubbles: true }) {\n    who.dispatchEvent(new CustomEvent(eventName, { ...options, detail: data }));\n}\nlet trackDeps = false;\nconst trackProxies = new Set();\nconst trackMap = new WeakMap();\nconst unobserveMap = new WeakMap();\nfunction watchEffect(fn) {\n    trackDeps = true;\n    fn();\n    trackDeps = false;\n    const reRun = (newVal) => {\n        if (newVal !== null)\n            fn();\n    };\n    for (const proxy of trackProxies) {\n        if (!trackMap.has(proxy))\n            continue;\n        for (const key of trackMap.get(proxy)) {\n            proxy.observe(key, reRun);\n            if (unobserveMap.has(reRun)) {\n                unobserveMap.get(reRun).push({ proxy, key });\n            }\n            else {\n                unobserveMap.set(reRun, [{ proxy, key }]);\n            }\n        }\n        trackMap.delete(proxy);\n    }\n    trackProxies.clear();\n    return () => unobserveMap\n        .get(reRun)\n        .forEach((entry) => entry.proxy.unobserve(entry.key, reRun));\n}\nfunction getValue(reactiveHydro) {\n    const [resolvedValue] = resolveObject(Reflect.get(reactiveHydro, keysSymbol.description));\n    return resolvedValue;\n}\nlet calledOnRender = false;\nfunction onRender(fn, elem, ...args) {\n    calledOnRender = true;\n    onRenderMap.set(elem, args.length ? fn.bind(fn, ...args) : fn);\n}\nlet calledOnCleanup = false;\nfunction onCleanup(fn, elem, ...args) {\n    calledOnCleanup = true;\n    onCleanupMap.set(elem, args.length ? fn.bind(fn, ...args) : fn);\n}\n// Core of the library\nfunction generateProxy(obj) {\n    const handlers = Symbol(\"handlers\"); // For observer pattern\n    const boundFunctions = new WeakMap();\n    const proxy = new Proxy(obj ?? {}, {\n        // If receiver is a getter, then it is the object on which the search first started for the property|key -> Proxy\n        set(target, key, val, receiver) {\n            if (trackDeps) {\n                trackProxies.add(receiver);\n                if (trackMap.has(receiver)) {\n                    trackMap.get(receiver).add(key);\n                }\n                else {\n                    trackMap.set(receiver, new Set([key]));\n                }\n            }\n            let returnSet = true;\n            let oldVal = Reflect.get(target, key, receiver);\n            if (oldVal === val)\n                return returnSet;\n            // Reset Path - mostly GC\n            if (val === null) {\n                // Remove entry from reactitivyMap underlying Map\n                if (reactivityMap.has(receiver)) {\n                    const key2NodeMap = reactivityMap.get(receiver);\n                    key2NodeMap.delete(String(key));\n                    if (key2NodeMap.size === 0) {\n                        reactivityMap.delete(receiver);\n                    }\n                }\n                // Inform the Observers about null change and unobserve\n                const observer = Reflect.get(target, handlers, receiver);\n                if (observer.has(key)) {\n                    let set = observer.get(key);\n                    for (const handler of set) {\n                        handler(null, oldVal);\n                    }\n                    set.clear();\n                    receiver.unobserve(key);\n                }\n                // If oldVal is a Proxy - clean it\n                if (isObject(oldVal) && isProxy(oldVal)) {\n                    reactivityMap.delete(oldVal);\n                    if (bindMap.has(oldVal)) {\n                        bindMap.get(oldVal).forEach(removeElement);\n                        bindMap.delete(oldVal);\n                    }\n                }\n                else {\n                    if (bindMap.has(receiver)) {\n                        bindMap.get(receiver).forEach(removeElement);\n                        bindMap.delete(receiver);\n                    }\n                }\n                // Remove item from array\n                /* c8 ignore next 4 */\n                if (!internReset && Array.isArray(receiver)) {\n                    receiver.splice(Number(key), 1);\n                    return returnSet;\n                }\n                return Reflect.deleteProperty(receiver, key);\n            }\n            // Set the value\n            if (isPromise(val)) {\n                const promise = val;\n                promise\n                    .then((value) => {\n                    // No Reflect in order to trigger the Getter\n                    receiver[key] = value;\n                })\n                    .catch((e) => {\n                    console.error(e);\n                    receiver[key] = null;\n                });\n                returnSet = Reflect.set(target, key, val, receiver);\n                return returnSet;\n            }\n            else if (isNode(val)) {\n                returnSet = Reflect.set(target, key, val, receiver);\n            }\n            else if (isObject(val) && !isProxy(val)) {\n                returnSet = Reflect.set(target, key, generateProxy(val), receiver);\n                // Recursively set properties to Proxys too\n                for (const [subKey, subVal] of Object.entries(val)) {\n                    if (isObject(subVal) && !isProxy(subVal)) {\n                        Reflect.set(val, subKey, generateProxy(subVal));\n                    }\n                }\n            }\n            else {\n                if (!reuseElements &&\n                    Array.isArray(receiver) &&\n                    receiver.includes(oldVal) &&\n                    receiver.includes(val) &&\n                    /* c8 ignore start */\n                    bindMap.has(val)) {\n                    const [elem] = bindMap.get(val);\n                    if (lastSwapElem !== elem) {\n                        const [oldElem] = bindMap.get(oldVal);\n                        lastSwapElem = oldElem;\n                        const prevElem = elem.previousSibling;\n                        const prevOldElem = oldElem.previousSibling;\n                        // Move it in the array too without triggering the proxy set\n                        const index = receiver.findIndex((i) => i === val);\n                        receiver.splice(Number(key), 1, val);\n                        receiver.splice(index, 1, oldVal);\n                        prevElem.after(oldElem);\n                        prevOldElem.after(elem);\n                    }\n                    return true;\n                }\n                else {\n                    /* c8 ignore end */\n                    returnSet = Reflect.set(target, key, val, receiver);\n                }\n            }\n            const newVal = Reflect.get(target, key, receiver);\n            // Check if DOM needs to be updated\n            // oldVal can be Proxy value too\n            if (reactivityMap.has(oldVal)) {\n                checkReactivityMap(oldVal, key, newVal, oldVal);\n            }\n            else if (reactivityMap.has(receiver)) {\n                checkReactivityMap(receiver, key, newVal, oldVal);\n            }\n            // current val (before setting) is a proxy - take over its keyToNodeMap\n            if (isObject(val) && isProxy(val)) {\n                if (reactivityMap.has(oldVal)) {\n                    // Store old reactivityMap if it is a swap operation\n                    reuseElements && tmpSwap.set(oldVal, reactivityMap.get(oldVal));\n                    if (tmpSwap.has(val)) {\n                        reactivityMap.set(oldVal, tmpSwap.get(val));\n                        tmpSwap.delete(val);\n                    }\n                    else {\n                        reactivityMap.set(oldVal, reactivityMap.get(val));\n                    }\n                }\n            }\n            // Inform the Observers\n            if (returnSet) {\n                Reflect.get(target, handlers, receiver)\n                    .get(key)\n                    ?.forEach((handler) => handler(newVal, oldVal));\n            }\n            // If oldVal is a Proxy - clean it\n            !reuseElements && oldVal && cleanProxy(oldVal);\n            return returnSet;\n        },\n        // fix proxy bugs, e.g Map\n        get(target, prop, receiver) {\n            if (trackDeps) {\n                trackProxies.add(receiver);\n                if (trackMap.has(receiver)) {\n                    trackMap.get(receiver).add(prop);\n                }\n                else {\n                    trackMap.set(receiver, new Set([prop]));\n                }\n            }\n            const value = Reflect.get(target, prop, receiver);\n            if (!isFunction(value)) {\n                return value;\n            }\n            if (!boundFunctions.has(value)) {\n                boundFunctions.set(value, value.bind(target));\n            }\n            return boundFunctions.get(value);\n        },\n    });\n    Reflect.defineProperty(proxy, \"isProxy\" /* Placeholder.isProxy */, {\n        value: true,\n    });\n    Reflect.defineProperty(proxy, \"asyncUpdate\" /* Placeholder.asyncUpdate */, {\n        value: globalSchedule,\n        writable: true,\n    });\n    Reflect.defineProperty(proxy, handlers, {\n        value: new Map(),\n    });\n    Reflect.defineProperty(proxy, \"observe\" /* Placeholder.observe */, {\n        value(key, handler) {\n            const map = Reflect.get(proxy, handlers);\n            if (map.has(key)) {\n                map.get(key).add(handler);\n            }\n            else {\n                map.set(key, new Set([handler]));\n            }\n        },\n        configurable: true,\n    });\n    Reflect.defineProperty(proxy, \"getObservers\" /* Placeholder.getObservers */, {\n        value() {\n            return Reflect.get(proxy, handlers);\n        },\n        configurable: true,\n    });\n    Reflect.defineProperty(proxy, \"unobserve\" /* Placeholder.unobserve */, {\n        value(key, handler) {\n            const map = Reflect.get(proxy, handlers);\n            if (key) {\n                if (map.has(key)) {\n                    if (handler == null) {\n                        map.delete(key);\n                    }\n                    else {\n                        const set = map.get(key);\n                        if (set?.has(handler)) {\n                            set.delete(handler);\n                        }\n                    }\n                }\n                /* c8 ignore next 3 */\n            }\n            else {\n                map.clear();\n            }\n        },\n        configurable: true,\n    });\n    if (!obj)\n        Reflect.defineProperty(proxy, _boundFunctions, {\n            value: boundFunctions,\n        });\n    return proxy;\n}\nfunction cleanProxy(proxy) {\n    if (isObject(proxy) && isProxy(proxy)) {\n        reactivityMap.delete(proxy);\n        /* c8 ignore next 4 */\n        if (bindMap.has(proxy)) {\n            bindMap.get(proxy).forEach(removeElement);\n            bindMap.delete(proxy);\n        }\n    }\n}\nfunction checkReactivityMap(obj, key, val, oldVal) {\n    const keyToNodeMap = reactivityMap.get(obj);\n    const nodeToChangeMap = keyToNodeMap.get(String(key));\n    if (nodeToChangeMap) {\n        /* c8 ignore next 5 */\n        if (Reflect.get(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */)) {\n            schedule(updateDOM, nodeToChangeMap, val, oldVal);\n        }\n        else {\n            updateDOM(nodeToChangeMap, val, oldVal);\n        }\n    }\n    if (isObject(val)) {\n        for (const [subKey, subVal] of Object.entries(val)) {\n            const subOldVal = (isObject(oldVal) && Reflect.get(oldVal, subKey)) || oldVal;\n            const nodeToChangeMap = keyToNodeMap.get(subKey);\n            if (nodeToChangeMap) {\n                /* c8 ignore next 5 */\n                if (Reflect.get(obj, \"asyncUpdate\" /* Placeholder.asyncUpdate */)) {\n                    schedule(updateDOM, nodeToChangeMap, subVal, subOldVal);\n                }\n                else {\n                    updateDOM(nodeToChangeMap, subVal, subOldVal);\n                }\n            }\n        }\n    }\n}\nfunction updateDOM(nodeToChangeMap, val, oldVal) {\n    nodeToChangeMap.forEach((entry) => {\n        // Circular reference in order to keep Memory low\n        if (isNode(entry)) {\n            /* c8 ignore next 5 */\n            if (!ignoreIsConnected && !entry.isConnected) {\n                const tmpChange = nodeToChangeMap.get(entry);\n                nodeToChangeMap.delete(entry);\n                nodeToChangeMap.delete(tmpChange);\n            }\n            return; // Continue in forEach\n        }\n        // For each change of the node update either attribute or textContent\n        for (const change of entry) {\n            const node = nodeToChangeMap.get(entry);\n            const [start, end, key] = change;\n            let useStartEnd = false;\n            if (isNode(val)) {\n                replaceElement(val, node);\n                if (val !== node) {\n                    nodeToChangeMap.delete(node);\n                    if (!isDocumentFragment(val)) {\n                        nodeToChangeMap.set(val, entry);\n                        nodeToChangeMap.set(entry, val);\n                    }\n                }\n            }\n            else if (isTextNode(node)) {\n                useStartEnd = true;\n                let text = node.nodeValue;\n                node.nodeValue =\n                    text.substring(0, start) + String(val) + text.substring(end);\n            }\n            else {\n                if (key === \"two-way\" /* Placeholder.twoWay */) {\n                    if (node instanceof HTMLInputElement &&\n                        node.type === \"radio\" /* Placeholder.radio */) {\n                        node.checked = Array.isArray(val)\n                            ? val.includes(node.name)\n                            : String(val) === node.value;\n                    }\n                    else if (node instanceof HTMLInputElement &&\n                        node.type === \"checkbox\" /* Placeholder.checkbox */) {\n                        node.checked = val;\n                    }\n                    else if (node instanceof HTMLTextAreaElement ||\n                        node instanceof HTMLSelectElement ||\n                        node instanceof HTMLInputElement) {\n                        node.value = String(val);\n                    }\n                }\n                else if (isFunction(val) || isEventObject(val)) {\n                    const eventName = key.replace(onEventRegex, \"\");\n                    node.removeEventListener(eventName, isFunction(oldVal) ? oldVal : oldVal.event);\n                    addEventListener(node, eventName, val);\n                }\n                else if (isObject(val)) {\n                    for (const [subKey, subVal] of Object.entries(val)) {\n                        if (isFunction(subVal) || isEventObject(subVal)) {\n                            const eventName = subKey.replace(onEventRegex, \"\");\n                            node.removeEventListener(eventName, isFunction(oldVal[subKey])\n                                ? oldVal[subKey]\n                                : oldVal[subKey].event);\n                            addEventListener(node, eventName, subVal);\n                        }\n                        else {\n                            setAttribute(node, subKey, subVal);\n                        }\n                    }\n                }\n                else {\n                    useStartEnd = true;\n                    let attr = node.getAttribute(key);\n                    if (attr) {\n                        attr = attr.substring(0, start) + String(val) + attr.substring(end);\n                        setAttribute(node, key, attr === String(val) ? val : attr);\n                    }\n                    else {\n                        setAttribute(node, key, val);\n                    }\n                }\n            }\n            if (useStartEnd) {\n                // Update end\n                change[1] = start + String(val).length;\n                // Because we updated the end, we also have to update the start and end for every other reactive change in the node, for the same key\n                if (allNodeChanges.has(node)) {\n                    let passedNode = false;\n                    for (const nodeChange of allNodeChanges.get(node)) {\n                        if (nodeChange === change) {\n                            passedNode = true;\n                            continue;\n                        }\n                        if (passedNode && (isTextNode(node) || key === nodeChange[2])) {\n                            const difference = String(oldVal).length - String(val).length;\n                            nodeChange[0] -= difference;\n                            nodeChange[1] -= difference;\n                        }\n                    }\n                }\n            }\n        }\n    });\n}\nfunction view(root, data, renderFunction) {\n    viewElements = true;\n    const rootElem = $(root);\n    const elements = getValue(data).map(renderFunction);\n    rootElem.append(...elements);\n    for (const elem of elements)\n        runLifecyle(elem, onRenderMap);\n    if (rootElem.hasChildNodes())\n        setReactivity(rootElem);\n    onCleanup(unset, rootElem, data);\n    viewElements = false;\n    observe(data, (newData, oldData) => {\n        /* c8 ignore start */\n        viewElements = true;\n        // Reset or re-use\n        if (!newData?.length ||\n            (!reuseElements && newData?.length === oldData?.length)) {\n            rootElem.textContent = \"\";\n        }\n        else if (reuseElements) {\n            for (let i = 0; i < oldData?.length && newData?.length; i++) {\n                oldData[i].id = newData[i].id;\n                oldData[i].label = newData[i].label;\n                newData[i] = oldData[i];\n            }\n        }\n        // Add to existing\n        if (oldData?.length &&\n            newData?.length > oldData?.length &&\n            newData[0] === oldData[0]) {\n            const length = oldData.length;\n            const slicedData = newData.slice(length);\n            const newElements = slicedData.map((item, i) => renderFunction(item, i + length));\n            rootElem.append(...newElements);\n            for (const elem of newElements)\n                runLifecyle(elem, onRenderMap);\n        }\n        // Add new\n        else if (oldData?.length === 0 || (!reuseElements && newData?.length)) {\n            if (!reuseElements && oldData?.length && rootElem.hasChildNodes()) {\n                rootElem.textContent = \"\";\n            }\n            const elements = newData.map(renderFunction);\n            rootElem.append(...elements);\n            for (const elem of elements)\n                runLifecyle(elem, onRenderMap);\n        }\n        if (rootElem.hasChildNodes())\n            setReactivity(rootElem);\n        viewElements = false;\n        /* c8 ignore end */\n    });\n}\nconst hydro = generateProxy();\nconst $ = document.querySelector.bind(document);\nconst $$ = document.querySelectorAll.bind(document);\nconst internals = {\n    compare,\n    allNodeChanges,\n    hydroToReactive,\n    boolAttrList,\n};\nexport { render, html, h, hydro, setGlobalSchedule, setReuseElements, setInsertDiffing, setShouldSetReactivity, setIgnoreIsConnected, reactive, unset, setAsyncUpdate, unobserve, observe, ternary, emit, watchEffect, internals, getValue, onRender, onCleanup, setReactivity, $, $$, view, };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}